{"result":{"history_size":2,"folders":["extracurricular"],"nr":367,"data":{"embed_links":[]},"created":"2025-01-29T12:59:30Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"m1p1kpfdhk144b","data":"m6hwy5e1cd7q2","v":"all","type":"create","when":"2025-01-29T12:59:30Z"},{"anon":"no","uid":"m1p1kpfdhk144b","data":"m6hx0yho9694bk","v":"all","type":"update","when":"2025-01-29T13:01:41Z"},{"anon":"no","uid":"llz2dt5jij45lu","to":"m6hwy5duwi1q1","type":"followup","when":"2025-01-30T07:30:15Z","cid":"m6j0mlgtccf1ql"}],"bucket_name":"Today","history":[{"anon":"no","uid":"m1p1kpfdhk144b","subject":"Οι εξετάσεις τελείωσαν, αλλά η C συνεχίζει","created":"2025-01-29T13:01:41Z","content":"<md>Καλημέρα συνάδερφοι,\nμπορεί το εξάμηνο να τελείωσε, αλλά δεν είναι καλό να σταματήσουμε να ασχολούμαστε με την C.\n\nΣήμερα, σας έχω ετοιμάσει ένα παράδειγμα από undefined behavior.\n\nΓια όσους δεν έχουν ακούσει τον παραπάνω όρο, μπορείτε να διαβάσετε [αυτό το άρθρο](https://en.cppreference.com/w/c/language/behavior).\ntl;gr: όταν στον κώδικά μας γράφουμε κάτι το οποίο δεν είναι αποδεκτό από το C-standard αλλά συμβατό με την σύνταξη της C, αφήνουμε τον εκάστοτε compiler να κάνει ότι θέλει με τον κώδικά μας.\nΑυτό οδηγεί στο undefined behavior, που από πολλούς έχει ονομαστεί και [nasal demon](https://en.wiktionary.org/wiki/nasal_demon).\n\n# Το πρόβλημα\nΩς καινούργιος προγραμματιστής ο Foo, που μόλις έμαθε πως λειτουργούν οι pointers, γράφει το παρακάτω πρόγραμμα:\n```c\n#include <stdio.h>\n\nint main() {\n  int *res1 = NULL;\n  int *res2;\n\n  printf(\"res1 = %p, res2 = %p\\n\", res1, res2);\n  printf(\"*res1 = %d\", *res1);\n  printf(\"*res2 = %d\", *res2);\n\n  return 0;\n}\n```\n\nΣκεφτείτε τι κάνει το παραπάνω πρόγραμμα, με βάση τις γνώσεις σας.\n\n# Random garbage....or perhaps not\nΟ Foo υποθέτει ότι η πρώτη γραμμή θα τυπώσει κάτι με την μορφή \"res1 = NULL, res2 = <τυχαία σκουπίδια>\" ενώ όταν έρθει η ώρα να εκτελεσθεί η δεύτερη γραμμή, το πρόγραμμα θα κρασάρει επειδή κάνει dereference null pointer.\nΠράγματι, εκτελώντας το συμβαίνει ακριβώς αυτό. Σκέφτεται τι θα συμβεί αν αλλάξει την σειρά των εντολών που εκτυπώνουν τα περιεχόμενα των res1, res2;\nΤο πρόγραμμα που προκύπτει είναι το παρακάτω:\n```c\n#include <stdio.h>\n\nint main() {\n  int *res1 = NULL;\n  int *res2;\n\n  printf(\"res1 = %p, res2 = %p\\n\", res1, res2);\n  printf(\"*res2 = %d\", *res2);\n  printf(\"*res1 = %d\", *res1);\n\n  return 0;\n}\n```\nΑυτή την φορά, η δεύτερη εντολή εκτελείται και τυπώνει έναν τυχαίο αριθμό και το πρόγραμμα κρασάρει στην εκτέλεση της 3ης εντολής. Tίποτα το απρόσμενο.\n\n# Ο φίλος του Foo\nΟ Foo ενθουσιασμένος που κατάλαβε πως λειτουργούν οι μεταβλητές τύπου pointer χωρίς αρχικές τιμές, στέλνει στον φίλο του τον Bar  το παραπάνω πρόγραμμα και τον ρωτάει τι θα τυπώσει.\nΟ Bar τρέχει το πρόγραμμα και παρατηρεί ότι δεν τρέχει καμία εντολή μετά την πρώτη εντολή εκτύπωσης, ενώ η πρώτη εντολή τυπώνει \"res1 = (nil), res2 = (nil)\".\n\nΜόλις το ακούει αυτό ο Foo παγώνει. Νομίζει ότι είτε ο Bar είναι τρελός, είτε ότι ο ίδιος είναι τρελός.\nΞεκινούν μια διαφωνία για το τι θα περιέχουν μεταβλητές της στοίβας χώρις αρχικές τιμές, η οποία δεν τους βγάζει πουθενά. Ο Foo λέει σκουπίδια, o Bar λεέι 0.\n\nΜετά από λίγη ώρα ο Foo σκέφτεται κάτι που εξηγεί τα πάντα. Μπορείτε να σκεφτείτε τι;\n\n# Η εξήγηση\nΟ Foo χρησιμοποιούσε GCC για να κάνει compile την C. Υπέθεσε(κακώς) ότι και ο Bar χρησιμοποιούσε GCC. Ωστόσο, ο Bar χρησιμοποιούσε έναν άλλο γνωστό compiler τον clang.\nΗ χρήση μη αρχικοποιημένων μεταβλητών, στην C είναι undefined behavior. Όπως αναφέραμε και πριν αυτό σημαίνει ότι κάθε compiler μπορεί να την ερμηνεύσει όπως θέλει.\nΟ GCC αφήνει στις μεταβλητές της στοίβας τυχαία σκουπίδια. Ο clang ωστόσο, αρχικοποιεί τις μεταβλητές της στοίβας πάντα με 0.\nΑυτό έχει ως αποτέλεσμα, ο ίδιος κώδικας να κάνει εντελώς διαφορετικά πράγματα ακόμη και στο ίδιο σύστημα.\n\n# Συμπέρασμα\nΔεν μπορούμε να κάνω κανένα assumption για το αποτέλεσμα της χρήσης undefined behavior, και για αυτό τον λόγο πρέπει να γνωρίζουμε πότε συμβαίνει και πώς να το αντιμετωπίσουμε.\nΑν υπάρχει ένα πράγμα που πρέπει να κρατήσουμε από την εμπειρία του Foo, ποιο πιστεύετε ότι είναι; Γράψτε σε followup κάτι καινούργιο που μάθατε διαβάζοντας το παραπάνω.\n\nΣας ευχαριστώ για τον χρόνο σας,\nhappy coding.</md>"},{"anon":"no","uid":"m1p1kpfdhk144b","subject":"Οι εξετάσεις τελείωσαν, αλλά η C συνεχίζει","created":"2025-01-29T12:59:30Z","content":"<md>Καλημέρα συνάδερφοι,\nμπορεί το εξάμηνο να τελείωσε, αλλά δεν είναι καλό να σταματήσουμε να ασχολούμαστε με την C.\n\nΣήμερα, σας έχω ετοιμάσει ένα παράδειγμα από undefined behavior.\n\nΓια όσους δεν έχουν ακούσει τον παραπάνω όρο, μπορείτε να διαβάσετε [αυτό το άρθρο](https://en.cppreference.com/w/c/language/behavior).\ntl;gr: όταν στον κώδικά μας γράφουμε κάτι το οποίο δεν είναι αποδεκτό από το C-standard αλλά συμβατό με την σύνταξη της C, αφήνουμε τον εκάστοτε compiler να κάνει ότι θέλει με τον κώδικά μας.\nΑυτό οδηγεί στο undefined behavior, που από πολλούς έχει ονομαστεί και [nasal demon](https://en.wiktionary.org/wiki/nasal_demon).\n\n# Το πρόβλημα\nΩς καινούργιος προγραμματιστής ο Foo, που μόλις έμαθε πως λειτουργούν οι pointers, γράφει το παρακάτω πρόγραμμα:\n```c\n#include <stdio.h>\n\nint main() {\n  int *res1 = NULL;\n  int *res2;\n\n  printf(\"res1 = %p, res2 = %p\\n\", res1, res2);\n  printf(\"*res1 = %d\", *res1);\n  printf(\"*res2 = %d\", *res2);\n\n  return 0;\n}\n```\n\nΣκεφτείτε τι κάνει το παραπάνω πρόγραμμα, με βάση τις γνώσεις σας.\n\n# Random garbage....or perhaps not\nΟ Foo υποθέτει ότι η πρώτη γραμμή θα τυπώσει κάτι με την μορφή \"res1 = NULL, res2 = <τυχαία σκουπίδια>\" ενώ όταν έρθει η ώρα να εκτελεσθεί η δεύτερη γραμμή, το πρόγραμμα θα κρασάρει επειδή κάνει dereference null pointer.\nΠράγματι, εκτελώντας το συμβαίνει ακριβώς αυτό. Σκέφτεται τι θα συμβεί αν αλλάξει την σειρά των εντολών που εκτυπώνουν τα περιεχόμενα των res1, res2;\nΤο πρόγραμμα που προκύπτει είναι το παρακάτω:\n```c\n#include <stdio.h>\n\nint main() {\n  int *res1 = NULL;\n  int *res2;\n\n  printf(\"res1 = %p, res2 = %p\\n\", res1, res2);\n  printf(\"*res2 = %d\", *res2);\n  printf(\"*res1 = %d\", *res1);\n\n  return 0;\n}\n```\nΑυτή την φορά, η δεύτερη εντολή εκτελείται και τυπώνει έναν τυχαίο αριθμό και το πρόγραμμα κρασάρει στην εκτέλεση της 3ης εντολής. Tίποτα το απρόσμενο.\n\n# Ο φίλος του Foo\nΟ Foo ενθουσιασμένος που κατάλαβε πως λειτουργούν οι μεταβλητές τύπου pointer χωρίς αρχικές τιμές, στέλνει στον φίλο του τον Bar  το παραπάνω πρόγραμμα και τον ρωτάει τι θα τυπώσει.\nΟ Bar τρέχει το πρόγραμμα και παρατηρεί ότι δεν τρέχει καμία εντολή μετά την πρώτη εντολή εκτύπωσης, ενώ η πρώτη εντολή τυπώνει \"res1 = (nil), res2 = (nil)\".\n\nΜόλις το ακούει αυτό ο Foo παγώνει. Νομίζει ότι είτε ο Bar είναι τρελός, είτε ότι ο ίδιος είναι τρελός.\nΞεκινούν μια διαφωνία για το τι θα περιέχουν μεταβλητές της στοίβας χώρις αρχικές τιμές, η οποία δεν τους βγάζει πουθενά. Ο Foo λέει σκουπίδια, o Bar λεέι 0.\n\nΜετά από λίγη ώρα ο Foo σκέφτεται κάτι που εξηγεί τα πάντα. Μπορείτε να σκεφτείτε τι;\n\n# Η εξήγηση\nΟ Foo χρησιμοποιούσε GCC για να κάνει compile την C. Υπέθεσε(κακώς) ότι και ο Bar χρησιμοποιούσε GCC. Ωστόσο, ο Bar χρησιμοποιούσε έναν άλλο γνωστό compiler τον clang.\nΗ χρήση μη αρχικοποιημένων μεταβλητών, στην C είναι undefined behavior. Όπως αναφέραμε και πριν αυτό σημαίνει ότι κάθε compiler μπορεί να την ερμηνεύση όπως θέλει.\nΟ GCC αφήνει στις μεταβλητές της στοίβας τυχαία σκουπίδια. Ο clang ωστόσο, αρχικοποιεί τις μεταβλητές της στοίβας πάντα με 0.\nΑυτό έχει ως αποτέλεσμα, ο ίδιος κώδικας να κάνει εντελώς διαφορετικά πράγματα ακόμη και στο ίδιο σύστημα.\n\n# Συμπέρασμα\nΔεν μπορούμε να κάνω κανένα assumption για το αποτέλεσμα της χρήσης undefined behavior, και για αυτό τον λόγο πρέπει να γνωρίζουμε πότε συμβαίνει και πώς να το αντιμετωπίσουμε.\nΑν υπάρχει ένα πράγμα που πρέπει να κρατήσουμε από την εμπειρία του Foo, ποιο πιστεύετε ότι είναι; Γράψτε σε followup κάτι καινούργιο που μάθατε διαβάζοντας το παραπάνω.\n\nΣας ευχαριστώ για τον χρόνο σας,\nhappy coding.</md>"}],"type":"note","anon_map":{},"tags":["extracurricular","student"],"tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Σταματίνα Ναδάλη","endorser":{"llz2bkutusi4ap":1705329568},"admin":false,"photo":null,"id":"ln8jya4m77l56n","photo_url":null,"published":true,"email":"sdi2300137@di.uoa.gr","us":false,"facebook_id":null},{"role":"student","name":"Ελένη Μουχλή","endorser":{},"admin":false,"photo":null,"id":"m1lupx1np3e7mm","photo_url":null,"published":true,"email":"sdi2400133@di.uoa.gr","us":false,"facebook_id":null},{"role":"student","name":"Αναστάσιος Τσιρκινίδης","endorser":{},"admin":false,"photo":null,"id":"m1qlywwup4r3vy","photo_url":null,"email":"sdi2400200@di.uoa.gr","us":false,"facebook_id":null},{"role":"student","name":"Giwrgos Dafnis","endorser":{},"admin":false,"photo":null,"id":"m20bq8lotxe2nq","photo_url":null,"email":"sdi2400036@uoa.gr","us":false,"facebook_id":null}],"unique_views":150,"children":[{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Και ο προγραμματισμός συνεχίζεται :)</p>\n<p></p>\n<p>Σε ευχαριστούμε πολύ για το εξαιρετικό write up! Δεν μιλήσαμε πολύ για το undefined behavior σε C στο μάθημα, παρά μόνο για το θέμα της μη αρχικοποιημένης μνήμης (uninitialized memory) και πως το πρόγραμμά μας μπορεί να διαβάσει &#34;σκουπίδια&#34;. Όταν η συμπεριφορά του προγράμματος είναι μη ορισμένη (έχει διαφορά από το <a href=\"https://predr.ag/blog/falsehoods-programmers-believe-about-undefined-behavior/\" target=\"_blank\" rel=\"noopener noreferrer\">implementation-specific behavior</a>), ο εκάστοτε μεταγλωττιστής μπορεί να αποφασίσει να κάνει &#34;ότι θέλει&#34; προκειμένου να κάνει το πρόγραμμά σας πιο γρήγορο (και όπως παρατήρησες, διαφορετικοί μεταγλωττιστές έχουν διαφορετικές στρατηγικές). Τέτοιες συμπεριφορές οδηγούν συχνά σε <a href=\"https://mohitmv.github.io/blog/Shocking-Undefined-Behaviour-In-Action/\" target=\"_blank\" rel=\"noopener noreferrer\">περίεργα παραδείγματα</a> και για αυτό είναι καλό να τις αποφεύγουμε όσο αυτό είναι εφικτό!</p>\n<p></p>\n<p>Υπάρχουν γλώσσες που δεν έχουν undefined behavior ώστε να μην έχουμε τέτοια προβλήματα; Ασφαλώς και λέγονται γενικά <a href=\"https://en.wikipedia.org/wiki/Memory_safety\" target=\"_blank\" rel=\"noopener noreferrer\">memory-safe</a> - θα δείτε κάποιες από αυτές σε επόμενα εξάμηνα (ή μόνοι/μόνες σας από τώρα!). Άρα αυτές οι memory-safe γλώσσες δεν έχουν προβλήματα; Νομίζω πως μπορείτε να μαντέψετε την απάντηση :)</p>","created":"2025-01-30T07:30:15Z","bucket_order":8,"bucket_name":"Week 1/26 - 2/1","type":"followup","tag_good":[{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["m1p1n3z3mo7eo"],"no_answer":0,"id":"m6j0mlgtccf1ql","updated":"2025-01-31T11:44:01Z","config":{"editor":"rte"}}],"tag_good_arr":["llz2dt5jij45lu","ln8jya4m77l56n","m1qlywwup4r3vy","m1lupx1np3e7mm","m20bq8lotxe2nq"],"anon_icons":true,"id":"m6hwy5duwi1q1","config":{"editor":"md","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":3,"num_favorites":5,"my_favorite":false,"is_bookmarked":true,"is_pinned":false,"is_tag_good":true,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372632605,"default_anonymity":"no"},"error":null,"aid":"mev6x0qz91m61s"}