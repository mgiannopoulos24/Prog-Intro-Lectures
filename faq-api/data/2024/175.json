{"result":{"history_size":2,"folders":["hw1","hw1∕rsa"],"nr":175,"data":{"embed_links":[]},"created":"2024-12-11T17:26:33Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"stud","uid":"m1uk2t96ljs7ds","data":"m4k5wu5vbft10k","v":"all","type":"create","when":"2024-12-11T17:26:33Z","uid_a":"a_0"},{"anon":"no","uid":"ln71y5aw8yv4sw","data":"m4kf5odsd8dqv","to":"m4k5wu5p3um10i","type":"i_answer","when":"2024-12-11T21:45:22Z"},{"anon":"stud","uid":"m1uk2t96ljs7ds","to":"m4k5wu5p3um10i","type":"followup","when":"2024-12-12T06:34:32Z","cid":"m4ky26xtl3e4zu","uid_a":"a_0"},{"anon":"no","uid":"ln71y5aw8yv4sw","to":"m4k5wu5p3um10i","type":"feedback","when":"2024-12-12T07:27:01Z","cid":"m4kzxovvgkk5vn"},{"anon":"no","uid":"ln71y5aw8yv4sw","data":"m4l01314ns923u","type":"i_answer_update","when":"2024-12-12T07:29:39Z"},{"anon":"stud","uid":"m1uk2t96ljs7ds","to":"m4k5wu5p3um10i","type":"feedback","when":"2024-12-12T07:42:44Z","cid":"m4l0hw8cz4r3vv","uid_a":"a_0"},{"anon":"no","uid":"ln71y5aw8yv4sw","to":"m4k5wu5p3um10i","type":"feedback","when":"2024-12-12T08:21:32Z","cid":"m4l1vt2mb8awv"},{"anon":"no","uid":"ln71y5aw8yv4sw","to":"m4k5wu5p3um10i","type":"feedback","when":"2024-12-12T10:11:37Z","cid":"m4l5tcy1ps1op"},{"anon":"no","uid":"llz2dt5jij45lu","data":"m4l9dzy245c67x","v":"all","type":"update","when":"2024-12-12T11:51:38Z"}],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"Πώς θα κάνω τους τύπους encrypt and decrypt να μου λειτουργήσουν","created":"2024-12-12T11:51:38Z","content":"<p></p>\n<p></p>\n<p>Αν βάλω double δίπλα στους τύπους μου βγάζει error. Αν δεν το κάνω πάλι μου βγάζει error και δεν ξέρω τι να κάνω και όχι το string που προτείνεται ότι θα μας ήταν χρήσιμο δεν βοήθησε καθόλου </p>"},{"anon":"stud","uid":"m1uk2t96ljs7ds","uid_a":"a_0","subject":"Πώς θα κάνω τους τύπους encrypt and decrypt να μου λειτουργήσουν","created":"2024-12-11T17:26:33Z","content":"<p><a href=\"/redirect/s3?bucket=uploads&amp;prefix=paste%2Fm1uk2t96ljs7ds%2Fb271b013e6a59bdf0d5e3d0d816bbec02aaec88e9c04400e7679cfdd0df3f3d5%2F17339377992542631973798923973380.jpg\" target=\"_blank\" rel=\"noopener noreferrer\">17339377992542631973798923973380.jpg</a></p>\n<p></p>\n<p>Αν βάλω double δίπλα στους τύπους μου βγάζει error. Αν δεν το κάνω πάλι μου βγάζει error και δεν ξέρω τι να κάνω και όχι το string που προτείνεται ότι θα μας ήταν χρήσιμο δεν βοήθησε καθόλου </p>"}],"type":"question","anon_map":{"m1uk2t96ljs7ds":"a_0"},"tags":["hw1","hw1∕rsa","student"],"tag_good":[],"unique_views":93,"children":[{"history_size":2,"folders":[],"data":{"embed_links":[]},"created":"2024-12-11T21:45:22Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"no","uid":"ln71y5aw8yv4sw","subject":"","created":"2024-12-12T07:29:39Z","content":"<p>Αρχικά να πω ότι το πρόγραμμα σου έχει διάφορα λάθη, όχι μόνο ένα.</p>\n<p>Καλό είναι σε αυτές τις περιπτώσεις να διαβάζετε το τι ακριβώς σας λέει το πρώτο σφάλμα που σας λέει ο compiler και να μην αγνοείτε το τι σας λέει.</p>\n<p>Συνήθως εκεί περιγράφει ποιο και που είναι το πρόβλημα που συνάντησε.</p>\n<p></p>\n<p>Επίσης καλό είναι να μην στέλνετε τόσο μεγάλο κομμάτι του κώδικα σας εδώ.</p>\n<p></p>\n<p>Τώρα για το double, με αυτό δηλώνεις μία μεταβλητή που εχει μεν μεγάλο εύρος, αλλά δεν μπορεί να αναπαραστήσει όλους τους ακεραίους σε αυτό το ευρος. κάνει στρογκυλοποιήσεις στον πλησιέστερο που μπορεί να αναπαραστήσει.</p>\n<p>Τι περιμένεις ας πούμε να τυπώσει το:</p>\n<p></p>\n<pre>\n#include &lt;stdio.h&gt;\nint main() {\n    double x=99999999999999999;\n    printf(&#34;%f\\n&#34;,x);\n}</pre>\n<p>Αν περιμένεις να δεις το 99999999999999999 να εκτυπώνεται, θα εκπλαγείς!</p>\n<p>Το παραπάνω τυπώνει 100000000000000000.000000!</p>\n<p></p>\n<p>Λόγω της μειωμένης ακρίβειας των double καθώς και το ότι έχουν δεκαδικό μέρος, η πράξη του υπολοίου διαίρεσης δεν έχει νόημα και δεν ορίζεται για αυτούς (ακόμα και αν οριζόταν, το αποτέλεσμα θα ήταν λάθος λόγω των στροκυλοποιήσεων που κάνουν).</p>\n<p></p>\n<p>Για να μπορέσεις να υπολογίσεις υπόλοιπο διαίρεσης, <strong>πρέπει οι αριθμοί να αναπαρίστανται με κάποιον οπό τους τύπους που αναπαριστούν ακέραιους</strong>.</p>\n<p></p>\n<p>Επίσης η πρώτη παράμετρος του προγράμματος περιέχει είτε το <strong>κείμενο</strong> &#34;enc&#34; είτε το <strong>κείμενο</strong> &#34;dec&#34;.</p>\n<p>Όταν περάσεις ένα τέτοιο κείμενο στη συνάρτηση atoll, τι αριθμός περιμένεις να είναι το αποτέλεσμά της;</p>\n<p></p>\n<p>Ακόμα στη θεωρία πως έχετε πει ότι συγκρίνουμε τα κείμενα δύο συμβολοσειρών;<br />Μήπως αντί για τον τελεστή == πρέπει να χρησιμοποιήσεις <strong>τη συνάρτηση strcmp</strong> για να πετύχεις κάτι τέτοιο;</p>\n<p></p>\n<p>Ο τελεστής ^ τι σημαίνει στη C;</p>\n<p>Μήπως δεν σημαίνει ύψωση σε δύναμη;</p>\n<p></p>\n<p>Και διάφορα άλλα, όμως προσπάθησε να λύσεις πρώτα αυτά... </p>"},{"anon":"no","uid":"ln71y5aw8yv4sw","subject":"","created":"2024-12-11T21:45:22Z","content":"<p>Αρχικά να πω ότι το πρόγραμμα σου έχει διάφορα λάθη, όχι μόνο ένα.</p>\n<p>Καλό είναι σε αυτές τις περιπτώσεις να διαβάζετε το τι ακριβώς σας λέει το πρώτο σφάλμα που σας λέει ο compiler και να μην αγνοείτε το τι ακτιβώς σας λέει.</p>\n<p>Συνήθως εκεί περιγράφει ακριβώς ποιο και που είναι το πρόβλημα που συνάντησε.</p>\n<p></p>\n<p>Επίσης καλό είναι να μην στέλνετε τόσο μεγάλο κομμάτι του κώδικα σας εδώ.</p>\n<p></p>\n<p>Τώρα για το double, με αυτό δηλώνεις μία μεταβλητή που εχει μεν μεγάλο εύρος, αλλά δεν μπορεί να αναπαραστήσει όλους τους ακεραίους σε αυτό το ευρος. κάνει στρογκυλοποιήσεις στον πλησιέστερο που μπορεί να αναπαραστήσει.</p>\n<p>Τι περιμένεις ας πούμε να τυπώσει το:</p>\n<p></p>\n<pre>\n#include &lt;stdio.h&gt;\nint main() {\n    double x=99999999999999999;\n    printf(&#34;%f\\n&#34;,x);\n}</pre>\n<p>Αν περιμένεις να δεις το 99999999999999999 να εκτυπώνεται, θα εκπλαγείς!</p>\n<p>Το παραπάνω τυπώνει 100000000000000000.000000!</p>\n<p></p>\n<p>Λόγω της μειωμένης ακρίβειας των double καθώς και το ότι έχουν δεκαδικό μέρος, η πράξη του υπολοίου διαίρεσης δεν έχει νόημα και δεν ορίζεται για αυτούς (ακόμα και αν οριζόταν, το αποτέλεσμα θα ήταν λάθος λόγω των στροκυλοποιήσεων που κάνουν).</p>\n<p></p>\n<p>Για να μπορέσεις να υπολογίσεις υπόλοιπο διαίρεσης, <strong>πρέπει οι αριθμοί να αναπαρίστανται με κάποιον οπό τους τύπους που αναπαριστούν ακέραιους</strong>.</p>\n<p></p>\n<p>Επίσης η πρώτη παράμετρος του προγράμματος περιέχει είτε το <strong>κείμενο</strong> &#34;enc&#34; είτε το <strong>κείμενο</strong> &#34;dec&#34;.</p>\n<p>Όταν περάσεις ένα τέτοιο κείμενο στη συνάρτηση atoll, τι αριθμός περιμένεις να είναι το αποτέλεσμά της;</p>\n<p></p>\n<p>Ακόμα στη θεωρία πως έχετε πει ότι συγκρίνουμε τα κείμενα δύο συμβολοσειρών;<br />Μήπως αντί για τον τελεστή == πρέπει να χρησιμοποιήσεις <strong>τη συνάρτηση strcmp</strong> για να πετύχεις κάτι τέτοιο;</p>\n<p></p>\n<p>Ο τελεστής ^ τι σημαίνει στη C;</p>\n<p>Μήπως δεν σημαίνει ύψωση σε δύναμη;</p>\n<p></p>\n<p>Και διάφορα άλλα, όμως προσπάθησε να λύσεις πρώτα αυτά... </p>"}],"type":"i_answer","tag_endorse_arr":[],"children":[],"id":"m4kf5odmobbqu","config":{"editor":"rte"},"is_tag_endorse":false},{"anon":"stud","folders":[],"data":null,"no_upvotes":0,"subject":"<pre>\n<code>int main(int argc, char ** argv) {\n  if (argc != 3) return 1;\n  printf(&#34;strcmp(arg1, arg2): %d %d\\n&#34;,\n         strcmp(argv[1], argv[2]), argv[1] == argv[2]);\n  return 0;\n}\n\nΟκ μου λέτε να χρησιμοποιήσω το παραπάνω string αλλά είπατε κιόλας ότι argv[1]=dec και argv[2]=e σας είχα ρωτήσει ότι πρέπει να έχουμε δύο διαφορετικά arguments ένα για το enc και ένα για το dec και μου είπατε ότι δεν χρειάζεται αλλα για να χρησιμοποιήσω το string που μου λέτε πρέπει το dec και το enc να είναι δύο διαφορετικά arguments. Άρα πρέπει να έχω δύο διαφορετικάarguments για το enc και το dec ναι ή όχι;</code></pre>","created":"2024-12-12T06:34:32Z","bucket_order":3,"bucket_name":"Today","type":"followup","tag_good":[],"uid":"m1uk2t96ljs7ds","uid_a":"a_0","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>η συμβολοσειρά &#34;enc&#34; και η συμβολοσειρά &#34;dec&#34; είναι πιθανές τιμές του πρώτου argument του προγράμματος, δηλαδή του argument που βρίσκεται στο argv[1].</p>\n<p></p>\n<p>το πρόγραμμα σου θα πρέπει να δει αν η συμβολοσειρά που περιέχεται στο συγκεκριμένο argument είναι ίδια με την συμβολοσειρά &#34;enc&#34; και να κάνει encrypt το μήνυμα, ή αν είναι ίδια με την συμβολοσειρά &#34;dec&#34; και να κάνει decrypt το μήνυμα, ή αν είναι οτιδήποτε άλλο να βγάλει σφάλμα.</p>","created":"2024-12-12T07:27:01Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"ln71y5aw8yv4sw","children":[],"tag_good_arr":[],"id":"m4kzxovvgkk5vn","updated":"2024-12-12T07:41:43Z","config":{"editor":"rte"}},{"anon":"stud","folders":[],"data":null,"subject":"Τότε εξηγήσετε μου πως βοηθά αυτό το ηλίθιο string. Γιατί όπως μου λέτε εσείς αυτό το string είναι εντελώς άχρηστο ","created":"2024-12-12T07:42:44Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"m1uk2t96ljs7ds","uid_a":"a_0","children":[],"tag_good_arr":[],"id":"m4l0hw8cz4r3vv","updated":"2024-12-12T07:42:44Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<p>σε ποιο string αναφέρεσαι;</p>\n<p></p>\n<p>string ονομάζουμε τις συμβολοσειρές.</p>\n<p>Στη C ένα σταθερό string μπορούμε να το αναπαραστήσουμε βάζοντας ένα κείμενο μέσα σε διπλά εισαγωγικά στον κώδικά μας.</p>\n<pre>\n&#34;this is a string&#34;</pre>\n<p>Ως τύπος δεδομένων είναι ένας δείκτης σε μία θέση μνήμης στην οποία ξεκινάει μία ακολουθία από χαρακτήρες που στο τέλος έχει τον ειδικό χαρακτήρα &#39;\\0&#39;.</p>\n<p></p>\n<p>αν έχεις σε μία μεταβλητή ένα string όπως για παράδειγμα στο argv[1], αυτό είναι ένας δείκτης σε μία θέση μνήμης στην οποία ξεκινάει το κείμενο που περιέχεται σε αυτή τη συμβολοσειρά.</p>\n<p>αν πας και συγκρίνεις την τιμή της μεταβλητής αυτής με τον τελεστή σύγκρισης == με κάποια άλλη συμβολοσειρά, ουσιαστικά θα συγκρίνεις το αν αυτοί οι δύο δείκτες δείχνουν στο ίδιο σημείο στη μνήμη του υπολογιστή, που κατά πάσα πιθανότητα θα είναι ψευδές, ακόμα και αν τα κείμενα των δύο συμβολοσειρών είναι ίδια, γιατί τα δύο κείμενα θα είναι αποθηκευμένα σε διαφορετικά σημεία στη μνήμη.</p>\n<p></p>\n<p>Για να μπορέσουμε να συγκρίνουμε τα κείμενα στα οποία δείχνουν οι δείκτες των συμβολοσειρών έχουμε τη συνάρτηση strcmp.</p>\n<p>Αν της δώσουμε δύο συμβολοσειρές, αυτή θα επιστρέψει 0 αν τα κείμενα τους είναι ίδια, ή κάποια άλλη τιμή αν τα κείμενα είναι διαφορετικά.</p>\n<p></p>\n<p>Δοκίμασε να τρέξεις το παρακάτω ως παράδειγμα:</p>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char ** argv) {\n  if (argc != 2) return 1;\n  \n  printf(&#34;Comparing with == %s and %s are &#34;,argv[1],&#34;test&#34;);\n\n  if(argv[1]==&#34;test&#34;) printf(&#34;the same\\n&#34;);\n  else printf(&#34;different\\n&#34;);\n  \n  printf(&#34;Comparing with strcmp %s and %s are &#34;,argv[1],&#34;test&#34;);\n\n  if(strcmp(argv[1],&#34;test&#34;)==0) printf(&#34;the same\\n&#34;);\n  else printf(&#34;different\\n&#34;);\n\n  return 0;\n}</pre>\n<p></p>\n<p>Αν τρέξεις το παραπάνω και του βάλεις για πρώτη παράμετρο τη λέξη &#34;test&#34; το αποτέλεσμα είναι:</p>\n<pre>\nComparing with == test and test are different\nComparing with strcmp test and test are the same</pre>\n<p>η σύγκριση δηλαδή με το == βγάζει λάθος αποτέλεσμα.</p>\n<p></p>\n<p>Οπότε για να γίνει σωστά η σύγκριση στο πρόγραμμά σου, θα πρέπει να το κάνεις με την strcmp όπως το κάνει το κάτω μισό του προηγούμενου παραδείγματος.</p>","created":"2024-12-12T08:21:32Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"ln71y5aw8yv4sw","children":[],"tag_good_arr":[],"id":"m4l1vt2mb8awv","updated":"2024-12-12T08:21:32Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<p>Επίσης να συμπληρώσω ότι στην εκφώνηση λέει:</p>\n<div title=\"Page 8\">\n<div>\n<div>\n<ul><li>\n<p>Το πρόγραμμά θα πρέπει να παίρνει 5 ορίσματα από την γραμμή εντολών στην μορφή <kbd>./rsa op e d p q</kbd>.<br />Tο πρώτο <kbd>op</kbd> επιτρέπεται να είναι &#34;<kbd>enc</kbd>&#34; (για encryption) και &#34;<kbd>dec</kbd>&#34; για decryption.</p>\n</li></ul>\n</div>\n</div>\n</div>\n<p>δηλαδή το op που ανάλογα με την τιμή του θα σου πει τι λειτουργία πρέπει να κάνεις, θα πρέπει να το πάρεις από το argv[1].</p>\n<p>Τα <kbd>e</kbd>, <kbd>d</kbd>, <kbd>p</kbd> και <kbd>q</kbd> είναι αριθμοί που θα πρέπει να τους πάρεις από τα <kbd>argv[2]</kbd>, <kbd>argv[3]</kbd>, <kbd>argv[4] </kbd>και <kbd>argv[5]</kbd> αντίστοιχα.</p>\n<p></p>\n<p>Αφότου ελέγξεις ότι τα παραπάνω πληρούν όλους τους περιορισμούς που λέει η εκφώνηση,</p>\n<p>θα πρέπει να δεις αν το op (δηλαδή το <kbd>argv[1]</kbd>) είχε ως τιμή τη λέξη &#34;enc&#34; και να εφαρμόσεις τον τύπο που έχει στην εκφώνηση για το encryption,</p>\n<p>ή αν το op (δηλαδή το <kbd>argv[1]</kbd>) είχε ως τιμή τη λέξη &#34;dec&#34; και να εφαρμόσεις τον τύπο που έχει στην εκφώνηση για το decryption.</p>\n<p></p>\n<p></p>","created":"2024-12-12T10:11:37Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"ln71y5aw8yv4sw","children":[],"tag_good_arr":[],"id":"m4l5tcy1ps1op","updated":"2024-12-12T10:11:37Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"m4ky26xtl3e4zu","updated":"2024-12-12T10:11:55Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"anon_icons":true,"id":"m4k5wu5p3um10i","config":{"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":3,"num_favorites":0,"my_favorite":false,"is_bookmarked":true,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372297854,"default_anonymity":"no"},"error":null,"aid":"mev6puggdh93py"}