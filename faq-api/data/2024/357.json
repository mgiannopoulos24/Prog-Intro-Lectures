{"result":{"history_size":1,"folders":["lectures"],"nr":357,"data":{"embed_links":[]},"created":"2025-01-19T08:58:45Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"stud","uid":"m1pefweqjap1nj","data":"m63dy14hh9hp6","v":"all","type":"create","when":"2025-01-19T08:58:45Z","uid_a":"a_0"},{"anon":"no","uid":"ln71y5aw8yv4sw","data":"m63ikp2aavx2sw","to":"m63dy149xdkp5","type":"i_answer","when":"2025-01-19T11:08:21Z"},{"anon":"no","uid":"ln71y5aw8yv4sw","data":"m63ioeewmco6kv","type":"i_answer_update","when":"2025-01-19T11:11:14Z"}],"bucket_name":"Today","history":[{"anon":"stud","uid":"m1pefweqjap1nj","uid_a":"a_0","subject":"λιστα","created":"2025-01-19T08:58:45Z","content":"<p>Καλημέρα,</p>\n<p></p>\n<p>στην υλοποίηση των αλγορίθμων για εισαγωγή εξαγωγη κλπ οι παρακάτω εντολές είναι ισοδύναμες?<br /><br />  *list = new_head;        list = &amp;new_head;<br /> list = &amp;((*list)-&gt;next);          *list = ((*list)-&gt;next);<br /><br /><br /></p>"}],"type":"question","anon_map":{"m1pefweqjap1nj":"a_0"},"tags":["lectures","student"],"tag_good":[],"unique_views":104,"children":[{"history_size":2,"folders":[],"data":{"embed_links":[]},"created":"2025-01-19T11:08:21Z","bucket_order":3,"tag_endorse":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Konstantinos Diakonos","endorser":{},"admin":false,"photo":null,"id":"m1pefweqjap1nj","photo_url":null,"published":true,"email":"sdi2400040@di.uoa.gr","us":false,"facebook_id":null}],"bucket_name":"Today","history":[{"anon":"no","uid":"ln71y5aw8yv4sw","subject":"","created":"2025-01-19T11:11:14Z","content":"<p>Όχι, οι παραπάνω εκφράσεις δεν κάνουν το ίδιο πράγμα.</p>\n<p>Δουλεύουν πάνω σε διπλούς (και παραπάνω) δείκτες, αλλά αλλάζουν διαφορετικό επίπεδο.</p>\n<p>Όταν έχεις:</p>\n<pre>\nΑ -&gt; Β -&gt; .... </pre>\n<p>το Α=... θα αλλάξει την τιμή (το που δείχνει δηλαδή) ο Α.</p>\n<p>το *Α=... θα αλλάξει την τιμή (το που δείχνει δηλαδή) ο Β.</p>\n<p></p>\n<p>Στο πρώτο που γράφεις:</p>\n<p>Έχεις μία συνάρτηση στην οποία έχεις περάσει σε μία παράμετρο με όνομα list έναν δείκτη με το που βρίσκεται μια άλλη μεταβλητή (της main στο παράδειγμα των διαφανειών) η οποία είναι και αυτή δείκτης σε <kbd>struct listnode</kbd>.</p>\n<p>Ο στόχος είναι να μπορέσει να πειράξει η συνάρτηση την τιμή της μεταβλητής της main, δηλαδή να αλλάξει το που δείχνει εκείνος ο δείκτης.</p>\n<p>Έχεις επίσης και μία άλλη τοπική μεταβλητή η οποία είναι δείκτης σε <kbd>struct listnode</kbd> και δείχνει σε ένα φρέσκο κόμβο της λίστας.</p>\n<p></p>\n<p>Με το  <kbd>*list = new_head;</kbd> έχεις πει:</p>\n<p>Άλλαξε την τιμή στο σημείο που δείχνει η παράμετρος <kbd>list</kbd> (δηλαδή την τιμή της μεταβλητή της main), βάζοντας της ίδια τιμή με αυτη που έχει η τοπική μεταβλητή <kbd>new_head</kbd> .</p>\n<p>Με αυτό, η main θα ξέρει πλέον τον νέο κόμβο σαν κεφαλή της λίστας όταν επιστρέψουμε σε αυτή.</p>\n<p></p>\n<p>Αντίθετα με το <kbd>list = &amp;new_head;</kbd> του έχεις πει:</p>\n<p>Ξέχνα συνάρτηση το που βρίσκεται η μεταβλητή της main (που σου περάσανε παράμετρο), από εδώ και πέρα θέλω να θυμάσαι το που βρίσκεται η τοπική μεταβλητή <kbd>new_head</kbd> στο <kbd>list</kbd>.</p>\n<p>Με αυτό έχουμε κάνει μια τρύπα στο νερό!</p>\n<p>Όταν επιστρέψουμε στη main, η μεταβλητή της που κρατάει τον πρώτο κόμβο δεν θα έχει αλλάξει, θα ξέρει ακόμα τον παλιό και ο νέος θα έχει χαθεί.</p>\n<p>Δεν θα γνωρίζει κανείς το που βρίσκεται ο νέος κόμβος!</p>\n<p></p>\n<p>Στο δεύτερο που γράφεις:</p>\n<p>Θέλεις να αφαιρέσεις ένα κόμβο από τη λίστα.</p>\n<p></p>\n<p>Για να το καταφέρεις αυτό υπάρχουν δύο περιπτώσεις:</p>\n<p>Αν είναι ο πρώτος, θα πρέπει να αλλάξει η μεταβλητή της main που δείχνει στον πρώτο κόμβο ώστε να  δείχνει στον αμέσως επόμενό του.</p>\n<p>Αν είναι οποιοσδήποτε άλλος, θα πρέπει να αλλάξει το μέλλος next του <kbd>struct listnode</kbd> του προηγούμενου κόμβου από αυτόν που σβήνεις ώστε να δείχνει στον επόμενο από αυτόν που σβήνεις.</p>\n<p></p>\n<p>Στη μεταβλητή <kbd>list</kbd> έχεις αρχικά το που βρίσκεται η μεταβλητή της main που κρατάει την αρχή της λίστας.</p>\n<p></p>\n<p>Με το  <kbd>list = &amp;((*list)-&gt;next);</kbd> του λες:</p>\n<p>Ξέχνα το που θυμόσουνα ότι ήταν η μεταβλητή που κρατάει την αρχή, τώρα θέλω να θυμάσαι στο list το που είναι το μέλλος next του <kbd>struct listnode</kbd> του κόμβου που μόλις κοίταξα.</p>\n<p>Έτσι ανά πάσα στιγμή στη μεταβλητή <kbd>list</kbd> έχεις ένα δείκτη στο σημείο το οποίο ενδεχομένως πρέπει να αλλάξεις ώστε να σβηστεί ο επόμενως κόμβος της λίστας και όταν έρθει η ώρα παρακάτω και βρεις τον κόμβο, με το *list = temp-&gt;next; πας και κάνεις την αλλαγή ώστε οι συνδέσεις της λίσταν να προσπερνάνε τον κόμβο που είναι να σβηστεί. Κάνεις δηλαδή τον δείκτη που έδειχνε στον προς κατάργηση κόμβο, να δείχνει στον επόμενο από τον προς κατάργηση κόμβο.</p>\n<p></p>\n<p>Αν όμως αντί για τα παραπάνω έγραφες <kbd>*list = ((*list)-&gt;next);</kbd> στην επανάληψη, του λες ότι θέλεις να αλλάξει τη μεταβλητή της main (εκεί δηλαδή που δείχνει αρχικά το <kbd>list</kbd>)<kbd> </kbd>και αντί να δείχνει στην αρχή της λίστας να δείχνει στον επόμενο από αυτόν κόμβο.</p>\n<p>Το παραπάνω θα εξαφανίσει τον τρέχον κόμβο από τη λίστα και μιας και είναι σε επανάληψη, όταν τελειώσει η συνάρτηση θα έχεις καταλήξει να έχεις εξαφανίσει από τη λίστα που ξέρει η main, όλους τους κόμβους μέχρι και εκείνον που θέλεις να σβήσεις!</p>\n<p></p>\n<p>Γενικά για να μην μπλέκεστε σε αυτά, καλό είναι τώρα στην αρχή να ζωγραφίζετε σχηματάκια με το τι υπάρχει και που δείχνει ο κάθε δείκτης.</p>\n<p>Βοηθάει αρκετά νομίζω για να καταλάβετε τι αλλάζει και που με κάθε εντολή.</p>"},{"anon":"no","uid":"ln71y5aw8yv4sw","subject":"","created":"2025-01-19T11:08:21Z","content":"<p>Όχι, οι παραπάνω εκφράσεις δεν κάνουν το ίδιο πράγμα.</p>\n<p>Δουλεύουν πάνω σε διπλούς (και παραπάνω) δείκτες, αλλά αλλάζουν διαφορετικό επίπεδο.</p>\n<p>Όταν έχεις:</p>\n<pre>\nΑ -&gt; Β -&gt; .... </pre>\n<p>το Α=... θα αλλάξει την τιμή (το που δείχνει δηλαδή) ο Α.</p>\n<p>το *Α=... θα αλλάξει την τιμή (το που δείχνει δηλαδή) ο Β.</p>\n<p></p>\n<p>Στο πρώτο που γράφεις:</p>\n<p>Έχεις μία συνάρτηση στην οποία έχεις περάσει σε μία παράμετρο με όνομα list έναν δείκτη με το που βρίσκεται μια άλλη μεταβλητή (της main στο παράδειγμα των διαφανειών) η οποία είναι και αυτή δείκτης σε <kbd>struct listnode</kbd>.</p>\n<p>Ο στόχος είναι να μπορέσει να πειράξει η συνάρτηση την τιμή της μεταβλητής της main, δηλαδή να αλλάξει το που δείχνει εκείνος ο δείκτης.</p>\n<p>Έχεις επίσης και μία άλλη τοπική μεταβλητή η οποία είναι δείκτης σε <kbd>struct listnode</kbd> και δείχνει σε ένα φρέσκο κόμβο της λίστας.</p>\n<p></p>\n<p>Με το  <kbd>*list = new_head;</kbd> έχεις πει:</p>\n<p>Άλλαξε την τιμή στο σημείο που δείχνει η παράμετρος <kbd>list</kbd> (δηλαδή την τιμή της μεταβλητή της main), βάζοντας της ίδια τιμή με αυτη που έχει η τοπική μεταβλητή <kbd>new_head</kbd> .</p>\n<p>Με αυτό, η main θα ξέρει πλέον τον νέο κόμβο σαν κεφαλή της λίστας όταν επιστρέψουμε σε αυτή.</p>\n<p></p>\n<p>Αντίθετα με το <kbd>list = &amp;new_head;</kbd> του έχεις πει:</p>\n<p>Ξέχνα συνάρτηση το που βρίσκεται η μεταβλητή της main (που σου περάσανε παράμετρο), από εδώ και πέρα θέλω να θυμάσαι το που βρίσκεται η τοπική μεταβλητή <kbd>new_head</kbd> στο <kbd>list</kbd>.</p>\n<p>Με αυτό έχουμε κάνει μια τρύπα στο νερό!</p>\n<p>Όταν επιστρέψουμε στη main, η μεταβλητή της που κρατάει τον πρώτο κόμβο δεν θα έχει αλλάξει, θα ξέρει ακόμα τον παλιό και ο νέος θα έχει χαθεί.</p>\n<p>Δεν θα γνωρίζει κανείς το που βρίσκεται ο νέος κόμβος!</p>\n<p></p>\n<p>Στο δεύτερο που γράφεις:</p>\n<p>Θέλεις να αφαιρέσεις ένα κόμβο από τη λίστα.</p>\n<p></p>\n<p>Για να το καταφέρεις αυτό υπάρχουν δύο περιπτώσεις:</p>\n<p>Αν είναι ο πρώτος, θα πρέπει να αλλάξει η μεταβλητή της main που δείχνει στον πρώτο κόμβο ώστε να  δείχνει στον αμέσως επόμενό του.</p>\n<p>Αν είναι οποιοσδήποτε άλλος, θα πρέπει να αλλάξει το μέλλος next του <kbd>struct listnode</kbd> του προηγούμενου κόμβου από αυτόν που σβήνεις ώστε να δείχνει στον επόμενο από αυτόν που σβήνεις.</p>\n<p></p>\n<p>Στη μεταβλητή <kbd>list</kbd> έχεις αρχικά το που βρίσκεται η μεταβλητή της main που κρατάει την αρχή της λίστας.</p>\n<p></p>\n<p>Με το  <kbd>list = &amp;((*list)-&gt;next);</kbd> του λες:</p>\n<p>Ξέχνα το που θυμόσουνα ότι ήταν η μεταβλητή που κρατάει την αρχή, τώρα θέλω να θυμάσαι στο list το που είναι το μέλλος next του <kbd>struct listnode</kbd> του κόμβου που μόλις κοίταξα.</p>\n<p>Έτσι ανά πάσα στιγμή στη μεταβλητή <kbd>list</kbd> έχεις ένα δείκτη στο σημείο το οποίο ενδεχομένως πρέπει να αλλάξεις ώστε να σβηστεί ο επόμενως κόμβος της λίστας και όταν έρθει η ώρα παρακάτω και βρεις τον κόμβο, με το *list = temp-&gt;next; πας και κάνεις την αλλαγή ώστε οι συνδέσεις της λίσταν να προσπερνάνε τον κόμβο που είναι να σβηστεί. Κάνεις δηλαδή τον δείκτη που έδειχνε στον προς κατάργηση κόμβο, να δείχνει στον επόμενο από τον προς κατάργηση κόμβο.</p>\n<p></p>\n<p>Αν όμως αντί για τα παραπάνω έγραφες <kbd>*list = ((*list)-&gt;next);</kbd> στην επανάληψη, του λες ότι θέλεις να αλλάξει τη μεταβλητή της main (εκεί δηλαδή που δείχνει αρχικά το <kbd>list</kbd>)<kbd> </kbd>και αντί να δείχνει στην αρχή της λίστας να δείχνει στον επόμενο από αυτόν κόμβο.</p>\n<p>Το παραπάνω θα εξαφανίσει τον τρέχον κόμβο από τη λίστα και μιας και είναι σε επανάληψη, όταν τελειώσει η συνάρτηση θα έχεις καταλήξει να έχεις εξαφανίσει από τη λίστα που ξέρει η main, όλους τους κόμβους μέχρι και εκείνον που θέλεις να σβήσεις!</p>\n<p></p>"}],"type":"i_answer","tag_endorse_arr":["m1pefweqjap1nj","llz2dt5jij45lu"],"children":[],"id":"m63ikp24q5f2sv","config":{"editor":"rte"},"is_tag_endorse":true}],"tag_good_arr":[],"no_answer":0,"anon_icons":true,"id":"m63dy149xdkp5","config":{"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":2,"num_favorites":0,"my_favorite":false,"is_bookmarked":false,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372617824,"default_anonymity":"no"},"error":null,"aid":"mev6wpcg7x05kn"}