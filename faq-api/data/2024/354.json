{"result":{"history_size":1,"folders":["lectures"],"nr":354,"data":{"embed_links":[]},"created":"2025-01-18T15:12:37Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"stud","uid":"m1pc9jeaa1v6ea","data":"m62buz4zini5rb","v":"all","type":"create","when":"2025-01-18T15:12:37Z","uid_a":"a_0"},{"anon":"no","uid":"ln71y5aw8yv4sw","data":"m62e1xsot6q437","to":"m62buz4sdrf5r9","type":"i_answer","when":"2025-01-18T16:14:01Z"}],"bucket_name":"Today","history":[{"anon":"stud","uid":"m1pc9jeaa1v6ea","uid_a":"a_0","subject":"BFS","created":"2025-01-18T15:12:37Z","content":"<p>Γεια σας! Εδώ ο κύριος στην διαλεξη 21 μας εδειξε τον αλγοριθμο BFS ο οποιος χρησιμοποιεί μια λίστα ως ουρά.Το List τι τυπου ειναι;Επίσης,δεν θα ηταν πιο αποδοτικο αν φτιαχναμε ενα struct queue με front και rear;</p>\n<p></p>\n<p>void bfs(Tree t) {<br /> List worklist = NULL;<br /> Tree tmp;<br /> insert(&amp;worklist, t);<br /> while(worklist) {<br /> tmp = pop_last(&amp;worklist);<br /> printf(&#34;%d &#34;, tmp-&gt;value);<br /> if (tmp-&gt;left) insert(&amp;worklist, tmp-&gt;left);<br /> if (tmp-&gt;right) insert(&amp;worklist, tmp-&gt;right);<br /> }<br />}</p>"}],"type":"question","anon_map":{"m1pc9jeaa1v6ea":"a_0"},"tags":["lectures","student"],"tag_good":[],"unique_views":106,"children":[{"history_size":1,"folders":[],"data":{"embed_links":[]},"created":"2025-01-18T16:14:01Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"no","uid":"ln71y5aw8yv4sw","subject":"","created":"2025-01-18T16:14:01Z","content":"<p>Το πως θα έχει οριστεί το List εξαρτάται από την υλοποίηση της λίστας που θα χρησιμοποιήσεις.</p>\n<p></p>\n<p>Η διαφάνεια το περιγράφει γενικά, δεν σε δεσμεύει να χρησιμοποιήσεις κάποια κάποια συγκεκριμένη υλοποίηση. </p>\n<p></p>\n<p>Αν για παράδειγμα χρησιμοποιήσεις τη λίστα που υπάρχει στην αρχή των διαφανειών της ίδιας διάλεξης, τότε εκεί λέει:</p>\n<div title=\"Page 13\">\n<div>\n<div>\n<div>\n<pre>\ntypedef struct listnode {int value; struct listnode * next;} * List;</pre>\n</div>\n</div>\n</div>\n</div>\n<p>οπότε το List εδώ το ορίζει ως </p>\n<pre>\nstruct listnode *</pre>\n<p> Για ρίξε και μία ματιά στο @346.</p>\n<p></p>\n<p>Τώρα αν χρησιμοποιήσεις μία απλά συνδεδεμένη λίστα όπως η παραπάνω, η <kbd>insert</kbd> στην αρχή θα ήταν σε χρόνο Ο(1), αλλά η <kbd>pop_last</kbd> θα ήθελε χρόνο Ο(n), οπότε δεν είναι το πιο αποδοτικό.</p>\n<p></p>\n<p>Θα μπορούσαμε πχ αντί για αυτή την υλοποίηση λίστας να χρησιμοποιήσουμε μία διπλά συνδεδεμένη λίστα που οι πράξεις και στα δύο της άκρα είναι Ο(1), ή μία πιο εξειδικευμένη υλοποίηση ουράς.</p>\n<p></p>\n<p>Ο αλγόριθμος διάσχισης BFS του δέντρου θα ήταν ακριβώς ίδιος, δεν θα άλλαζε.</p>"}],"type":"i_answer","tag_endorse_arr":[],"children":[],"id":"m62e1xshrez436","config":{"editor":"rte"},"is_tag_endorse":false}],"tag_good_arr":[],"no_answer":0,"anon_icons":true,"id":"m62buz4sdrf5r9","config":{"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":2,"num_favorites":0,"my_favorite":false,"is_bookmarked":false,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372611373,"default_anonymity":"no"},"error":null,"aid":"mev6wkdbwxmp9"}