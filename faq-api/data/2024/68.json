{"result":{"history_size":2,"folders":["extracurricular"],"nr":68,"data":{"embed_links":[]},"created":"2024-11-01T04:18:41Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"llz2dt5jij45lu","data":"m2y85khlzp07jh","v":"all","type":"create","when":"2024-11-01T04:18:41Z"},{"anon":"no","uid":"llz2dt5jij45lu","data":"m2y866cf8kr16r","v":"all","type":"update","when":"2024-11-01T04:19:09Z"},{"anon":"no","uid":"m1rw6l586a35d7","to":"m2y85khan9b7jg","type":"followup","when":"2024-11-01T10:28:01Z","cid":"m2ylcj4jerm2tz"},{"anon":"no","uid":"llz2dt5jij45lu","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T15:24:41Z","cid":"m2yvy1hzmul7cl"},{"anon":"no","uid":"m1pclyywpzg20t","to":"m2y85khan9b7jg","type":"followup","when":"2024-11-01T17:02:21Z","cid":"m2yzfnqv8653rm"},{"anon":"stud","uid":"m1p1n3z3mo7eo","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T17:16:55Z","cid":"m2yzydhrw316xh","uid_a":"a_0"},{"anon":"no","uid":"m1p1kpfdhk144b","to":"m2y85khan9b7jg","type":"followup","when":"2024-11-01T18:08:06Z","cid":"m2z1s7dpw4h6g3"},{"anon":"no","uid":"m1p1kpfdhk144b","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T18:09:54Z","cid":"m2z1uj0cxh223t"},{"anon":"no","uid":"llz2dt5jij45lu","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T18:51:12Z","cid":"m2z3bmu9aqw72y"},{"anon":"no","uid":"llz2dt5jij45lu","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T19:00:07Z","cid":"m2z3n3lqbes157"},{"anon":"no","uid":"m1w5urtwklx4r8","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-01T22:55:13Z","cid":"m2zc1fi2j1h40o"},{"anon":"no","uid":"llz2dt5jij45lu","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T04:55:49Z","cid":"m2zox611mlap1"},{"anon":"no","uid":"m1p1kpfdhk144b","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T08:50:57Z","cid":"m2zxbk3y7fm1df"},{"anon":"no","uid":"m1p1kpfdhk144b","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T09:31:54Z","cid":"m2zys7wfvfi7hr"},{"anon":"no","uid":"m1w5urtwklx4r8","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T11:30:21Z","cid":"m3030jgm85ldl"},{"anon":"no","uid":"m1p1kpfdhk144b","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T12:16:33Z","cid":"m304nyeux001qj"},{"anon":"no","uid":"m1w5urtwklx4r8","to":"m2y85khan9b7jg","type":"feedback","when":"2024-11-02T13:03:27Z","cid":"m306ca67kxb1of"}],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"Πυθαγόριες Τριπλέτες - Συνέχεια","created":"2024-11-01T04:19:09Z","content":"<p>Καλημέρα σας,</p>\n<p></p>\n<p>Χθες το βράδυ με την βοήθεια του Γιώργου, καταφέραμε να λύσουμε <a href=\"https://projecteuler.net/problem=9\" target=\"_blank\" rel=\"noopener noreferrer\">πρόβλημα 9 του project euler</a> και η λύση στην οποία καταλήξαμε ήταν η ακόλουθη:</p>\n<p></p>\n<pre>\n/* Program to compute the sole pythagorean\n   triplet where a &#43; b &#43; c == 1000. Implements\n   the solution to https://projecteuler.net/problem=9\n*/\n\n#include &lt;stdio.h&gt;\n\nint main() {\n  // For each combination of a, b, c check\n  // whether the conditions a &#43; b &#43; c == 1000\n  // and a^2 &#43; b^2 == c^2 are met\n  for (int a = 1; a &lt;= 1000; a&#43;&#43;) {\n    for (int b = 1; b &lt;= 1000; b&#43;&#43;) {\n      for (int c = 1; c &lt;= 1000; c&#43;&#43;) {\n        if ((a &lt; b) &amp;&amp; (b &lt; c) &amp;&amp; (a * a &#43; b * b == c * c) &amp;&amp;\n            (a &#43; b &#43; c == 1000)) {\n          printf(&#34;a: %d\\nb: %d\\nc: %d\\n&#34;, a, b, c);\n          printf(&#34;abc:%d\\n&#34;, a * b * c);\n          return 0;\n        }\n      }\n    }\n  }\n  return 0;\n}</pre>\n<p></p>\n<p>Η λύση μας παρόλο που θέλει ~1 δισεκατομμύριο επαναλήψεις τρέχει σε μόλις 0.4 δευτερόλεπτα - το οποίο είναι αρκετά γρήγορο, στο site του projecteuler το ανεπίσημο όριο για να βρεις την &#34;λύση&#34; είναι στα 60 δευτερόλεπτα.</p>\n<p></p>\n<p>Παρόλα αυτά, στο μάθημα αναφέρθηκαν πολλές δυνατότητες βελτίωσης αυτού του αλγορίθμου. Έχετε κάποια ιδέα για το πως θα μπορούσαμε να το κάνουμε αυτό; Αν ναι, μοιραστείτε το εδώ μαζί μας!</p>\n<p></p>\n<p>Καλή συνέχεια,</p>\n<p>Θανάσης</p>\n<p></p>"},{"anon":"no","uid":"llz2dt5jij45lu","subject":"Πυθαγόριες Τριπλέτες - Συνέχεια","created":"2024-11-01T04:18:41Z","content":"<p>Καλημέρα σας,</p>\n<p></p>\n<p>Χθες το βράδυ με την βοήθεια του Γιώργου, καταφέραμε να λύσουμε <a href=\"https://projecteuler.net/problem=9\" target=\"_blank\" rel=\"noopener noreferrer\">πρόβλημα 9 του project euler</a> και η λύση στην οποία καταλήξαμε ήταν η ακόλουθη:</p>\n<p></p>\n<pre>\n/* Program to compute the sole pythagorean\n   triplet where a &#43; b &#43; c == 1000. Implements\n   the solution to https://projecteuler.net/problem=9\n*/\n\n#include &lt;stdio.h&gt;\n\nint main() {\n  // For each combination of a, b, c check\n  // whether the conditions a &#43; b &#43; c == 1000\n  // and a^2 &#43; b^2 == c^2 are met\n  for (int a = 1; a &lt;= 1000; a&#43;&#43;) {\n    for (int b = 1; b &lt;= 1000; b&#43;&#43;) {\n      for (int c = 1; c &lt;= 1000; c&#43;&#43;) {\n        if ((a &lt; b) &amp;&amp; (b &lt; c) &amp;&amp; (a * a &#43; b * b == c * c) &amp;&amp;\n            (a &#43; b &#43; c == 1000)) {\n          printf(&#34;a: %d\\nb:%d\\nc: %d\\n&#34;, a, b, c);\n          printf(&#34;abc:%d\\n&#34;, a * b * c);\n          return 0;\n        }\n      }\n    }\n  }\n  return 0;\n}</pre>\n<p></p>\n<p>Η λύση μας παρόλο που θέλει ~1 δισεκατομμύριο επαναλήψεις τρέχει σε μόλις 0.4 δευτερόλεπτα - το οποίο είναι αρκετά γρήγορο, στο site του projecteuler το ανεπίσημο όριο για να βρεις την &#34;λύση&#34; είναι στα 60 δευτερόλεπτα.</p>\n<p></p>\n<p>Παρόλα αυτά, στο μάθημα αναφέρθηκαν πολλές δυνατότητες βελτίωσης αυτού του αλγορίθμου. Έχετε κάποια ιδέα για το πως θα μπορούσαμε να το κάνουμε αυτό; Αν ναι, μοιραστείτε το εδώ μαζί μας!</p>\n<p></p>\n<p>Καλή συνέχεια,</p>\n<p>Θανάσης</p>\n<p></p>"}],"type":"note","anon_map":{"m1p1n3z3mo7eo":"a_0"},"tags":["extracurricular","instructor-note"],"tag_good":[{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"unique_views":125,"children":[{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<md>Καλησπέρα,\n\nΜε μία συμφοιτήτρια σκεφτήκαμε αυτό:\n```\n/* Program to compute the sole pythagorean  \n   triplet where a + b + c == 1000. Implements  \n   the solution to https://projecteuler.net/problem=9  \n*/\n\n#include <stdio.h>\n\nint main() {  \n  // For each combination of a, b, c check  \n  // whether the conditions a + b + c == 1000  \n  // and a^2 + b^2 == c^2 are met  \n  for (int c = 1; c <= 1000; c++) {  \n    for (int b = 1; b < c; b++) {  \n      for (int a = 1; a < b; a++) {  \n        if ((a * a + b * b == c * c) && (a + b + c == 1000)) {  \n          printf(\"a: %d\\nb:%d\\nc: %d\\n\", a, b, c);  \n          printf(\"abc:%d\\n\", a * b * c);  \n          return 0;  \n        }  \n      }  \n    }  \n  }  \n  return 0;  \n}\n```\nΗ συμαντικότερη διαφορά είναι πως οι δομές επαναλήψης εκτελούνται με άλλη σειρά. Δηλαδή ξεκινάει από τη μεταβλητή c, ώστε η for της b να περιέχει τη συνθήκη b < c και παρομοίως για τη for της a με την συνθήκη a < b. Αυτή η αλλαγή έχει ως αποτέλεσμα να εκτελούνται λιγότερες επαναλήψεις (αυτές που δεν τηρούν τη συνθήκη a < b < c) και να μη χρειάζεται καν η συνθήκη \n```\nif ((a < b) && (b < c))\n```\nγιατί αυτή εξασφαλίζεται από την μορφή των επαναλήψεων.</md>","created":"2024-11-01T10:28:01Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1rw6l586a35d7","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>Εξαιρετικά! Χρησιμοποιήσατε τους περιορισμούς των αριθμών για να μειώσετε τις επαναλήψεις στα nested loops! Με ένα πρόχειρο υπολογισμό φαίνεται να ρίχνει το κόστος σχεδόν στο ~1/9 του αρχικού!</p>\n<p></p>\n<pre>\n# original version\n$ time ./1\na: 200\nb: 375\nc: 425\nabc:31875000\n\nreal 0m0.442s\nuser 0m0.438s\nsys 0m0.004s\n\n# improved version\n$ time ./2 \na: 200\nb:375\nc: 425\nabc:31875000\n\nreal 0m0.056s\nuser 0m0.052s\nsys 0m0.004s</pre>\n<p></p>","created":"2024-11-01T15:24:41Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"m2yvy1hzmul7cl","updated":"2024-11-01T15:24:41Z","config":{"editor":"rte"}}],"tag_good_arr":["llz2dt5jij45lu"],"no_answer":0,"id":"m2ylcj4jerm2tz","updated":"2024-11-01T18:57:45Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<md>Καλησπέρα σας,\nΜία πιθανή βελτιστοποίηση που σκέφρηκα είναι η εξής:\n```c\n#include <stdio.h>\n#include <math.h>\n#define LIMIT 1000\n\nint main(void)\n{\n\tfor (int a = 3; a <= LIMIT; a++)\n\t{\n\t\tfor (int b = a+1; b <= LIMIT; b++)\n\t\t{\n\t\t\tfloat c = sqrtf(a*a + b*b);\n\t\t\tif (a+b+c > 1000) break;\n\t\t\t\n\t\t\telse if (c == (int)c && a+b+c == 1000)\n\t\t\t{\n\t\t\t\tprintf(\"found product: %d\\n\", a*b*(int)c);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn 1;\n}\n```\n## Επεξήγηση \nΚαταρχήν ξέρουμε ότι η πρώτη πυθαγόρεια τριάδα ξεκινάει με **a = 3**. Γνωρίζοντας αυτό μπορούμε να σκιπάρουμε (στο αρχικό πρόγραμμα) 3x1.000x1.000 = **3.000.000** περριτές επαναλήψεις.  \nΕπίσης, για να είναι μία τριάδα αριθμών σωστή πυθαγόρεια τριάδα, θα πρέπει a < b. Οπότε κάθε φορά η 2η επανάληψη αρχίζει απο a+1, σώζοντάς μας από περισσότερες περιττές επαναλήψεις.  \n### Όχι 3ο loop??\nΣτην πραγματικότητα, δεν χρειάζεται να κάνουμε extra itteration για να βρούμε ποιός αριθμός κάθε φορά ικανοποιεί την πυθαγόρεια τριάδα με βάση τα δεδομένα κάθε φορά a και b. Απλά για κάθε a και b, υπολογίζουμε εμείς εκείνον τον αριθμό:  \n`float c = sqrtf(a*a + b*b)`  \nΕπειδή όμως ο c μπορεί να βγει και δεκαδικός αριθμός (ενω εμείς αναζητάμε αυστηρά φυσικούς), πρέπει να ελέγξουμε αν ο c είναι φυσικός:  \n`c == (int)c`  \nΕπίσης, αν κατά την διάρκεια μιας επανάληψης διαπιστώσουμε πως το άθροισμα `a+b+c` είναι μεγαλύτερο του 1000, δεν υπάρχει λόγος να συνεχίσουμε την επανάληψη, οπότε φεύγουμε από αυτήν:  \n`if (a+b+c > 1000) break`  \nΤέλος, όταν βρούμε την κατάλληλη τριάδα τυπώνουμε το γινόμενό τους και τελειώνουμε το πρόγραμμα.  \n## Run time\nΚαθώς δεν μπορούσα να τρέξω την εντολή `time`, δεν γνωρίζω κατά πόσο (και εάν) αυτή η λύση είναι γρηγορότερη από την αρχική.</md>","created":"2024-11-01T17:02:21Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1pclyywpzg20t","children":[{"anon":"stud","folders":[],"data":null,"subject":"Σύμφωνα με το δικο μου συστημα ειναι 400x γρηγοροτερη :)","created":"2024-11-01T17:16:55Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[{"role":"student","name":"Χρήστος Βιντσάνι","endorser":{},"admin":false,"photo":"709b1941-8068-4a49-9e0a-b0e0c4d99a53_200.jpg","id":"m1pclyywpzg20t","photo_url":"https://cdn-uploads.piazza.com/photos/m1pclyywpzg20t/709b1941-8068-4a49-9e0a-b0e0c4d99a53_200.jpg","published":true,"email":"sdi2400018@di.uoa.gr","us":false,"facebook_id":null},{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1p1n3z3mo7eo","uid_a":"a_0","children":[],"tag_good_arr":["m1pclyywpzg20t","llz2dt5jij45lu"],"id":"m2yzydhrw316xh","updated":"2024-11-01T18:40:22Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<p>Πάρα πολύ δυνατή η επιτάχυνση! Ουσιαστικά γλυτώνεις ένα loop το οποίο σου δίνει επιτάχυνση σχεδόν 3 τάξεων μεγέθους!!</p>\n<p></p>\n<p>Σε ένα σημείο μόνο θέλω να προσέχουμε λίγο:</p>\n<p></p>\n<pre>\n   float c = sqrtf(a*a &#43; b*b);\n   if (a&#43;b&#43;c &gt; 1000) break;\n   \n   else if (c == (int)c &amp;&amp; a&#43;b&#43;c == 1000)</pre>\n<p></p>\n<p>στην προκειμένη περίπτωση είσαι οκ καθώς όντως παίρνεις το σωστό αποτέλεσμα, αλλά γενικά προτείνω να αποφεύγουμε floats και χρήση ισότητας. Θα σας δείξω ένα παράδειγμα στην επόμενη διάλεξη, ευχαριστώ για την πάσα!</p>","created":"2024-11-01T18:51:12Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[{"role":"student","name":"Χρήστος Βιντσάνι","endorser":{},"admin":false,"photo":"709b1941-8068-4a49-9e0a-b0e0c4d99a53_200.jpg","id":"m1pclyywpzg20t","photo_url":"https://cdn-uploads.piazza.com/photos/m1pclyywpzg20t/709b1941-8068-4a49-9e0a-b0e0c4d99a53_200.jpg","published":true,"email":"sdi2400018@di.uoa.gr","us":false,"facebook_id":null},{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["m1pclyywpzg20t","m1p1n3z3mo7eo"],"id":"m2z3bmu9aqw72y","updated":"2024-11-01T19:16:12Z","config":{"editor":"rte"}}],"tag_good_arr":["llz2dt5jij45lu"],"no_answer":0,"id":"m2yzfnqv8653rm","updated":"2024-11-01T18:51:12Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<md># Απλοποίηση\nΜπορούμε να παρατηρήσουμε ότι οι συνθήκες `a < b && b < c` δεν  είναι απαραίτητες διότι οι βρόγχοι εκτελούνται με αύξουσα σειρά.\nΑυτό σημαίνει ότι σε κάθε επανάληψη που είναι πιθανό να ισχύουν τα απαιτούμενα κριτήρια, ήδη θα ισχύει a < b < c.\nΗ εκτέλεση του κώδικα χωρίς τις συνθήκες έχει το ίδιο ακριβώς αποτέλεσμα.\nΈτσι ο κώδικας μετατρέπεται στο παρακάτω:\n```c\n#include <stdio.h>\nint main() {\n  for (int a = 1; a <= 1000; a++) {\n    for (int b = 1; b <= 1000; b++) {\n      for (int c = 1; c <= 1000; c++) {\n        if (a * a + b * b == c * c && a + b + c == 1000) { // extra conditions removed\n          printf(\"a: %d\\nb: %d\\nc: %d\\n\", a, b, c);\n          printf(\"abc:%d\\n\", a * b * c);\n          return 0;\n        }\n      }\n    }\n  }\n  return -1;\n}\n```\n\n# But wait, there's more\nΗ παραπάνω βελτίση μας γλίτωσε λίγα CPU cycles, αλλά ο κύριος ένοχος που καταναλώνει κύκλους δεν ήταν οι συγκρίσεις.\nΑς σκεφτούμε λίγο τι γνωρίζουμε για τους αριθμούς a, b και  c.\n$$ a + b + c = 1000 $$ και $$ a^2 + b^2 = c^2 $$.\nΑυτά τα ερμηνεύσαμε ως συνθήκες όταν λύναμε το πρόβλημα στην τάξη. Ωστόσο, μπορούμε να τα ερμηνεύσουμε και ως ορισμούς για τους αριθμούς που ψάχνουμε.\nie. Ψάχνουμε εκείνα τα a, b και c για τα οποία ισχύει $$ a + b + c = 1000 $$ και $$ a^2 + b^2 = c^2 $$.\nΣκεφτόμενοι έτσι παρατηρούμε ότι το c  μπορεί να περιοριστεί με την χρήση του πρώτου μέρους του ορισμού:\n$$\na + b + c = 1000 \\Rightarrow c = 1000 - a - b\n$$\nΣτην ουσία μπορούμε λοιπόν να υπολογίσουμε το c για κάθε δεδομένο a και b. Ύστερα μπορούμε να ελέγξουμε απλά αν το  c αυτό ικανοποιεί το δεύτερο μέρος του ορισμού.\nΜπορούμε λοιπόν να αποφύγουμε την εσωτερική επανάληψη για την εύρεση του c και να την αντικαταστήσουμε 2 προσθέσεις. Αυτό μπορεί να διαιρέσει τον συνολικό χρόνο εκτέλεσης που προγράμματος κατά 1000.\nΕφαρμόζοντας τα παραπάνω προκύπτει ο εξής κώδικας:\n```c\n#include <stdio.h>\nint main() {\n  for (int a = 1; a <= 1000; a++) {\n    for (int b = 1; b <= 1000; b++) {\n      int c = 1000 - a - b; // since a + b + c = 1000, we can define c as a function of a and b\n      if (a * a + b * b == c * c) {\n        printf(\"a: %d\\nb: %d\\nc: %d\\n\", a, b, c);\n        printf(\"abc:%d\\n\", a * b * c);\n        return 0;\n      }\n    }\n  }\n  return -1;\n}\n```\n# So is that all?\nΒασικά μπορούμε να μειώσουμε ακόμη περισσότερο τις επαναλήψεις που θα εκτελεστούν. Στην τάξη κάποιος(άφησε ένα σχόλιο παρακάτω για credits αν γίνεται) είχε αναφέρει ότι:\n> Αφού a < b και a, b ακέραιοι, δεν μπορούμε να ξεκινήσουμε την εσωτερική επανάληψη με αρχική τιμή του b την a + 1;\n\nΚαι πράγματι, σαν επιχείρημα στέκει και μειώνει σημαντικά τον αριθμό των επαναλήψεων.\nΈτσι από $$1000^2$$ μπορούμε να κάνουμε την εκτέλεση σε $$1000 + 999 + 998 + 997 + ... + 1 = \\frac{1000(1000 + 1)}{2}= 500,500$$ επαναλήψεις. Αυτές είναι οι μισές από το προηγούμενο βήμα και $$\\frac{1,000,000,000}{500,500} \\approx 2000$$ φορές πιο γρήγορα από το αρχικό πρόγραμμα.\nΟ κώδικας που προκύπτει είναι ο παρακάτω:\n```c\n#include <stdio.h>\n\nint main() {\n  for (int a = 1; a <= 1000; a++) {\n    for (int b = a + 1; b <= 1000; b++) {\n      // since a + b + c = 1000, we can define c as a function of a and b\n      int c = 1000 - a - b;\n      if (a * a + b * b == c * c) {\n        printf(\"a: %d\\nb: %d\\nc: %d\\n\", a, b, c);\n        printf(\"abc:%d\\n\", a * b * c);\n        return 0;\n      }\n    }\n  }\n  return -1;\n}\n```\n\n# Surely it can't get any better...\nΤελικά μήπως δεν γίνεται καλύτερα;\nΣε προβλήματα του Project Euler καλό είναι να θυμόμαστε ότι η συγκεκριμένη σελίδα περιέχει κυρίως μαθηματικά προβλήματα.\n\n## Μαθηματικά\nΘα μου πάρει πολύ χρόνο να ξαναγράψω αυτά που έγραψα όταν πρωτοκοίταξα το πρόβλημα. Για να μην σας(και μου) πάρω χρόνο, θα στείλω το PNG που δημιούργησα όταν έλυσα το πρόβλημα.  \nΣτην ουσία του, έχουμε 3 μεταβλητές και 2 εξισώσεις. Αυτό σημαίνει ότι κατά πάσα πιθανότητα έχουμε 1 βαθμό ελευθερίας, έναν αριθμό από τον οποίο εξαρτώνται οι άλλοι 2. Με λίγες πράξεις χρησιμοποιώντας τον ορισμό των αριθμών μπορούμε εύκολα να δείξουμε ότι το b μπορεί να εκφραστεί συναρτήσει του a και αντίστροφα το  a συναρτήσει του b(παρατηρούμε εξ'αρχής ότι το πρόβλημα είναι συμμετρικό ως προς a και b, ie μπορούμε να αλλάξουμε τις θέσεις των μεταβλητών και θα έχουμε το ίδιο πρόβλημα.\nΜε τον τρόπο αυτό προκύπτει το παρακάτω:\n$$\nb = 1000\\frac{500 - a}{1000 - a}, 0 < a < 1000\n$$  \n$$\nc = 1000 - a - b\n$$  \n***\nΈτσι το πρόβλημα εύρεσης της μοναδικής πυθαγόρειας τριάδας που να ικανοποιεί τους ορισμούς μας, μετατρέπεται σε πρόβλημα εύρεσης του μοναδικού a για τον οποίο τα b και c που προκύπτουν με τον παραπάνω τρόπο δημιουργούν με αυτό πυθαγόρεια τριάδα.\n\n## C\nΧρησιμοποιώντας τα παραπάνω μπορούμε να εξαλήψουμε και τον εσωτερικό βρόχο και να υπολογίσουμε το b και το c με απλές πράξεις(κάτι που είναι υπερβολικά γρήγορο για τους υπολογιστές.\nΕφαρμόζοντας τα παραπάνω προκύπτει ο εξής κώδικας:\n```c\n#include <stdio.h>\nint main() {\n  for (int a = 1; a < 1000; a++) {\n    // mathemagic\n    int b = 1000 * (500 - a) / (1000 - a);\n    int c = 1000 - a - b;\n    if (a * a + b * b == c * c) {\n      printf(\"a: %d, b: %d, c: %d\\n\", a, b, c);\n      printf(\"abc = %d\\n\", a * b * c);\n      return 0;\n    }\n  }\n\n  return -1;\n}\n```\nΟ παραπάνω κώδικας, στην χειρότερη περίπτωση εκτελεί 1000 επαναλήψεις. Αυτό σημαίνει ότι είναι περίπου $$1,000,000$$ φορές πιο γρήγορος από την αρχική μας λύση.\n***\n# Τhe End\nΤέλος αν ενδιαφερόμαστε τόσο πολύ για επίδοση, θα μπορούσαμε να περάσουμε το -Ofast flag στο gcc κατά το compilation προκειμένου να χρησιμοποιήσει διάφορες βελτιώσεις για να επιταχύνει την εκτέλεση του προγράμματος(δεν το δοκίμασα).</md>","created":"2024-11-01T18:08:06Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Panagiotis Zarganitis","endorser":{},"admin":false,"photo":null,"id":"m1w5urtwklx4r8","photo_url":null,"email":"sdi2400045@uoa.gr","us":false,"facebook_id":null},{"role":"ta","name":"Stathis Konstantinou","endorser":{},"admin":true,"photo":"f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","id":"lndeeow72a32qc","photo_url":"https://cdn-uploads.piazza.com/photos/lndeeow72a32qc/f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","published":true,"email":"sdi2300099@di.uoa.gr","us":false,"admin_permission":5,"facebook_id":null},{"role":"student","name":"Αναστάσιος Τσιρκινίδης","endorser":{},"admin":false,"photo":null,"id":"m1qlywwup4r3vy","photo_url":null,"email":"sdi2400200@di.uoa.gr","us":false,"facebook_id":null}],"uid":"m1p1kpfdhk144b","children":[{"anon":"no","folders":[],"data":null,"subject":"<a href=\"/redirect/s3?bucket=uploads&amp;prefix=paste%2Fm1p1kpfdhk144b%2F1ab5e04e05c539d10f649b038244ffc1978fafe1693a7eb81cc474853161678e%2FUntitled-2024-11-01-1918.png\" target=\"_blank\" rel=\"noopener noreferrer\">Ορίστε ένα followup με τις προαναφερθήσες πράξεις</a>","created":"2024-11-01T18:09:54Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Panagiotis Zarganitis","endorser":{},"admin":false,"photo":null,"id":"m1w5urtwklx4r8","photo_url":null,"email":"sdi2400045@uoa.gr","us":false,"facebook_id":null}],"uid":"m1p1kpfdhk144b","children":[],"tag_good_arr":["llz2dt5jij45lu","m1w5urtwklx4r8"],"id":"m2z1uj0cxh223t","updated":"2024-11-01T22:56:39Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<p>Καταπληκτικό write up από την αρχή ως το τέλος! Νομίζω άνετα γινόταν ένα ωραιότατο technical blogpost. Σε ευχαριστούμε πολύ που το μοιράστηκες!</p>\n<p></p>\n<p>Υπάρχει μια πιθανότητα μάλιστα το loop να μην μπορεί να εκτελεστεί πάνω από 500 φορές καθώς το b παραπάνω θα γινόταν αρνητικό!</p>","created":"2024-11-01T19:00:07Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["m1p1n3z3mo7eo"],"id":"m2z3n3lqbes157","updated":"2024-11-01T19:16:49Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Πιστεύω υπάρχει κάτι ακόμη που μπορεί να επιταχύνει τον αλγόριθμο. Χρησιμοποιώντας SIMD μπορούμε να κάνουμε τον έλεγχο της συνθήκης `a * a + b * b == c * c` παράλληλο.\n\nΠαρατηρούμε ότι οι αριθμοί a, b και c είναι σχετικά μικρού μεγέθους, δηλαδή και αυτοί και οι `a*a`, `b*b` και `c*c` χωράνε μέσα σε 16 bit. Αυτό μας βολεύει διότι μπορούμε να τους \"πακετάρουμε\" μέσα σε ειδικούς καταχωρητές του επεξεργαστή των 64 bit ως `4x int16_t`. Αυτοί οι καταχωρητές λέγονται και αλλιώς vectors, οπότε θα χρησιμοποιήσω τους αντίστοιχους συμβολισμούς της γραμμικής άλγεβρας.\n\nΘα \"πακετάρουμε\" τους `a`, `b`, και `c` μέσα σε έναν τέτοιο καταχωρητή που θα τον ονομάσουμε `v`. Οι καταχωρητές αυτοί έχουν 64 bits, άρα και χώρο για `64 / 16 = 4` προσημασμένους αριθμούς των 16 bit, οπότε θα βάλουμε και ένα 0 στο τέλος. Έχουμε λοιπόν ότι:\n\n$$\nv =\n\\begin{bmatrix}\na \\\\ b \\\\ c \\\\ 0\n\\end{bmatrix}\n$$\n\nΕμείς θέλουμε να υπολογίσουμε τα τετράγωνα των αριθμών. Σύμφωνα με [το εγχειρίδιο της Intel](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=2746,2681,2664,2662,3235,4684,4720,4639,4769,5097,2674,4684,3674,3674,4726,3688,3674,3668,4651,4894,5091,4892,4893,5178,5179,5091,5180,7115,3686,3687,3682,3687,5676,912,4902,5091,&text=_mm_mullo_pi16), μπορούμε να κάνουμε πολλαπλασιασμό στο `v` με μια εντολή που λέγεται `_mm_mullo_pi16` (δεν θα μπω σε λεπτομέρειες εδώ, δείτε το εγχειρίδιο). Θα μπορούσαμε λοιπόν να κάνουμε `u = _mm_mullo_pi16(v, v);` για να υπολογίσουμε τα τετράγωνα. Τότε θα είχαμε:\n\n$$\nu =\n\\begin{bmatrix}\na^2 \\\\ b^2 \\\\ c^2 \\\\ 0\n\\end{bmatrix}\n$$\n\nΜετά πρέπει να βγάλουμε τα τετράγωνα από το `u` (όχι ιδιαίτερα γρήγορο) και να υπολογίσουμε το άθροισμα καθώς και να κάνουμε τον έλεγχο ισότητας. Όμως μπορούμε και καλύτερα! Οι μηχανικοί της Intel δεν μας έδωσαν ένα σώρο τέτοια ωραία εργαλεία για να κάνουμε μόνο πολλαπλασιασμούς! Behold την εντολή [`_m_pmaddwd`](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=2746,2681,2664,2662,3235,4684,4720,4639,4769,5097,2674,4684,3674,3674,4726,3688,3674,3668,4651,4894,4892,4893,5178,5179,5091,5180,7115,3686,3687,3682,3687,5676,912,4902,5091,5091,5091&text=_m_pmadd)! Μας λέει η Intel για αυτή την εντολή:\n\n> Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst.\n\nΝαι οκ ωραία τα λένε αλλά τι σημαίνουν όλα αυτά; Πρακτικά σημαίνει ότι θα μας υπολογίσει και τα τετράγωνα και το άθροισμά τους με τη μια. Όποτε, αν ορίσουμε `u = _m_pmaddwd(v, v)`, τότε μετά θα καταλήξουμε να έχουμε:\n\n$$\nu =\n\\begin{bmatrix}\na^2 + b^2 \\\\ c^2\n\\end{bmatrix}\n$$\n\nΠροσέξτε ότι ένω εμείς δώσαμε στην `_m_pmaddwd` το `v` (`4x int16_t`), τώρα το `u` είναι `2x int32_t`. Οπότε το μόνο που μένει είναι να τσεκάρουμε ότι τα πρώτα 32 bits του `u` είναι ίσα με τα τελευταία 32 bits. Αυτό γίνεται με πολλούς τρόπους. Μπορούμε να το κάνουμε με άλλη μια τέτοια περίεργη εντολή ή ακόμα και κατευθείαν με τον τελεστή `==` της C. Στην ουσία θέλουμε να συγκρίνουμε 2 αριθμούς. Στην συγκεκριμένη περίπτωση όμως δεν μας ενδιαφέρει η πληροφορία ποιος είναι μεγαλύτερος ή μικρότερος, απλά αν είναι ίσοι ή όχι. Μπορούμε να κάνουμε $$u_1 \\oplus u_2$$ το οποίο θα μας δώσει 0 μόνο όταν  $$u_1 = u_2$$ (με τον ίδιο τρόπο ελέγχονται και αριθμοί στην κρυπτογραφία). Το πρόβλημα με τον τελεστή ισότητας είναι ότι ανάλογα με τον μεταγλωτιστή μπορούμε να καταλήξουμε να κάνουμε αφαίρεση (οι υπολογιστές για να συγκρίνουν αριθμούς κάνουν αφαίρεση και συγκρίνουν το αποτέλεσμα με 0) που συχνά είναι πιο αργή από ένα απλό XOR. To be on the safe side θα κάνουμε XOR.\n\nΜετά από όλο αυτό, ίσως και άχρηστο, rant δείτε τον κώδικα:\n\n```c\n#include <stdio.h>\n#include <mmintrin.h>\n\nint main() {\n  for (int a = 1; a < 1000; a++) {\n    // mathemagic\n    int b = 1000 * (500 - a) / (1000 - a);\n    int c = 1000 - a - b;\n\n    // load a, b, c and 0 into v\n    __m64 v = _mm_set_pi16(a, b, c, 0);\n\n    // compute the sum of squares\n    __m64 u = _m_pmaddwd(v, v);\n\n    // u[0] and u[1] take the low and high 32 bits as an int32_t respectively\n    if ((u[0] ^ u[1]) == 0) {\n      printf(\"a: %d, b: %d, c: %d\\n\", a, b, c);\n      printf(\"abc = %d\\n\", a * b * c);\n      return 0;\n    }\n  }\n\n  return -1;\n}\n```\n\nCompile with:\n\n```bash\n$ gcc -Wall -Werror -Wextra -pedantic -Ofast -mavx -mfma -msse -mmmx -o main main.c\n```\n\nΣτο μηχάνημα μου μέτρησα επιτάχυνση ~50μs σε σχέση με την έξυπνη λύση του Πέτρου. And it goes without saying, όλα αυτά δουλεύουν μόνο σε x86_64, οπότε :P.</md>","created":"2024-11-01T22:55:13Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"ta","name":"Stathis Konstantinou","endorser":{},"admin":true,"photo":"f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","id":"lndeeow72a32qc","photo_url":"https://cdn-uploads.piazza.com/photos/lndeeow72a32qc/f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","published":true,"email":"sdi2300099@di.uoa.gr","us":false,"admin_permission":5,"facebook_id":null}],"uid":"m1w5urtwklx4r8","children":[],"tag_good_arr":["llz2dt5jij45lu","lndeeow72a32qc"],"id":"m2zc1fi2j1h40o","d-bucket":"Yesterday","updated":"2024-11-02T15:40:09Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"subject":"<p>Και αυτό είναι υλικό για blogpost κατά την γνώμη μου :)</p>\n<p></p>\n<p>Για όλα τα άλλα παιδιά που τα βλέπουν και πιθανώς να μην τους βγάζει νόημα / τρομάζουν: να πω ότι αυτά είναι θέματα αρχιτεκτονικής και θα τα δείτε μόνο σε μεγαλύτερα έτη και τέτοιες λεπτομέρειες μόνο σε κάποια μαθήματα επιλογής. Αν κάποιος ενδιαφέρεται να μάθει περισσότερα για το τι είναι το SIMD: <a href=\"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/Single_instruction,_multiple_data</a></p>\n<p></p>\n<p>Στο προκείμενο: να πω ότι αν και έχω ξαναδεί την pmaddwd στο παρελθόν δεν είχα φανταστεί ποτέ ότι μπορεί να φανεί χρήσιμη σε κάποιον - οπότε props και μόνο για αυτό!</p>\n<p></p>\n<p>Από εκεί και πέρα: να πούμε πως επειδή εδώ οι επαναλήψεις (στον βελτιστοποιημένο αλγόριθμο) είναι σχετικά μικρές, δεν μπορείτε αναγκαστικά να εμπιστεύεστε το timing που βλέπετε εκτός αν έχετε ειδικά εργαλεία / προσομοιωτές που μετρούν με ακρίβεια κύκλου. Διαφορετικά στον υπολογιστή σας τρέχουν και ένα σωρό άλλα πράγματα και πιθανώς να δημιουργούν παρεμβολές.</p>\n<p></p>\n<p>Για μια γρήγορη (αλλά και πάλι ανακριβή) μέτρηση πάντως να πω πως το <a href=\"https://en.wikipedia.org/wiki/Perf_%28Linux%29\" target=\"_blank\" rel=\"noopener noreferrer\">perf</a> είναι ένα αρκετά χρήσιμο εργαλείο (apt install linux-perf), καθώς μπορεί να σου δώσει αρκετά χαρακτηριστικά για το πρόγραμμά σου - για παράδειγμα πόσες εντολές / κύκλους έτρεξε στον επεξεργαστή (perf stat -e cycles,instructions ./myprog) καθώς τρέχει μαζί με όλα τα υπόλοιπα στον υπολογιστή σου.</p>","created":"2024-11-02T04:55:49Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[{"role":"student","name":"Panagiotis Zarganitis","endorser":{},"admin":false,"photo":null,"id":"m1w5urtwklx4r8","photo_url":null,"email":"sdi2400045@uoa.gr","us":false,"facebook_id":null},{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["m1w5urtwklx4r8","m1p1n3z3mo7eo"],"id":"m2zox611mlap1","d-bucket":"Yesterday","updated":"2024-11-02T14:42:35Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Πολύ σωστός ο συνάδελφος με τα SIMD instructions. Θεωρώ όμως ότι είναι πολύ πιθανό να γίνεται behind-the-scenes optimization όταν περνάς Ο3 ή Οfast που όντως θα το υλοποιεί με SIMD μιας που συνήθως κάτι τέτοια κάνει το Ο3. Επίσης όπως σωστά ανέφερε ο συνάδελφος αυτή η λύση περιορίζει το πεδίο επίλυσης στην x86_64 πλατφόρμα (η οποία όμως είναι η μεγαλύτερη πλατφόρμα επεξεργαστών σήμερα). Mad respect. Δεν θα καθόμουν να έψαχνα SIMD για project euler problem but performance is performance.","created":"2024-11-02T08:50:57Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Panagiotis Zarganitis","endorser":{},"admin":false,"photo":null,"id":"m1w5urtwklx4r8","photo_url":null,"email":"sdi2400045@uoa.gr","us":false,"facebook_id":null}],"uid":"m1p1kpfdhk144b","children":[],"tag_good_arr":["llz2dt5jij45lu","m1w5urtwklx4r8"],"id":"m2zxbk3y7fm1df","d-bucket":"Yesterday","updated":"2024-11-02T11:30:54Z","config":{}},{"anon":"no","folders":[],"data":null,"subject":"<md>Να ρωτήσω κάτι επίσης: πώς μέτρησες την διαφορά αυτή;\nΕγώ χρησιμοποιώ το hyperfine με τα ίδια compilation flags και για τα δύο προγράμματα και στο δικό μου σύστημα\n(AMD Ryzen 5600x Arch Linux, μόνο awesome, kitty, zsh ενεργά) προκύπτουν τα παρακάτω αποτελέσματα:  \n![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fm1p1kpfdhk144b%2F8f1c71150b5ca6b9e4be52dc4d0a5821ce44eb59948dab45cb6fb46cce9e8701%2Fimage.png)\n\nΦυσικά δεν θέλω να πω ότι το version μου είναι καλύτερο. Τα benchmarks μια βγαίνουν με το δικό μου πιο γρήγορο μία με το δικό σου. Είναι statistically minor η διαφορά. Όταν το συνολικό runtime είναι περίπου 330μs, claims για 50μs boost δεν είναι statistically minor.</md>","created":"2024-11-02T09:31:54Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1p1kpfdhk144b","children":[],"tag_good_arr":["llz2dt5jij45lu"],"id":"m2zys7wfvfi7hr","updated":"2024-11-03T08:16:25Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Κοίτα είναι αρκετά δύσκολο να μετρήσεις τι πραγματικό impact έχει το SIMD σε τόσο μικρό πρόβλημα. Όλα τα benchmarks τα έτρεξα πάντως στο laptop μου (Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz) που είχε τουλάχιστον 1 browser ανοιχτό με μουσική, το thermald, όλο το KDE Plasma και ένα σωρό άλλα πράγματα (δες <https://github.com/threadexio/dotfiles/blob/master/hosts/ares/default.nix>) που αυξομειώνουν και την ταχύτητα του επεξεργαστή και πόσο αυτός χρησιμοποιείται.\n\nΣτα tests δεν είχα συνεχώς 50μs speedup. Κάποιες φορές ήταν πιο αργό κατά μερικά μs, άλλες φορές ήταν πιο γρήγορο σε τάξη των 70μs. Από τις παρατηρήσεις μου βρήκα ότι γενικά, στο δικό μου μηχάνημα με τον δικό μου επεξεργαστή και kernel (linux-zen), έτεινε γενικά να βρισκέται εκεί κοντά στα 50μs.\n\nΒέβαια μέσα στο manual της Intel αναφέρει ότι διαφορετικές SIMD εντολές έχουν διαφορετική καθυστέρηση από γενιά σε γενιά. Φαντάζομαι η AMD έχει διαφορετικό implementation για αυτές τις εντολές, κάποιες ίσως τις κάνουν emulate με microcode (δεν το θεωρώ πολυ πιθανό αλλά ποτέ δεν θα μάθουμε), οπότε δεν ξέρω κατά πόσο είναι επιστημονικό να μιλάμε για performance numbers.\n\nΌσο για την μέτρηση των χρόνων, δεν χρησιμοποίησα κανένα εξωτερικό εργαλείο. Όλα χρονομετρήθηκαν internally. Είχα μια συνάρτηση που ήταν ο αλγόριθμος της λύσης που ήταν marked ως `__attribute__((always_inline))` και στην αρχή και στο τέλος είχα `clock_gettime(CLOCK_PROCESS_CPUTIME_ID)`. Στο τέλος αφού υπολογιστεί η τριάδα απλά τύπωνα και την διαφορά του ρολογιού (ακρίβεια nanosecond). Ήθελα να αποφύγω γενικά το `perf` που ανέφερε ο κ. Αυγερινός διότι, ενώ χρησιμοποιεί hardware counters που είναι νομίζω η  μόνη πηγή αλήθειας, εγώ δεν ξέρω να το χειρίζομαι τόσο κάλα.</md>","created":"2024-11-02T11:30:21Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1w5urtwklx4r8","children":[],"tag_good_arr":["llz2dt5jij45lu"],"id":"m3030jgm85ldl","updated":"2024-11-03T08:16:27Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Υπάρχει κάποιο πρόβλημα αν δημοσιεύσω τον κωδικά σου σε GitHub repository κάτω από MIT License;\nΕννοείται αν θες στείλε μου το username σου για να σε αναφέρω.</md>","created":"2024-11-02T12:16:33Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1p1kpfdhk144b","children":[],"tag_good_arr":["llz2dt5jij45lu"],"id":"m304nyeux001qj","updated":"2024-11-03T08:16:30Z","config":{"editor":"md"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Κανένα απολύτως! [threadexio](https://github.com/threadexio/) με λένε στο github παντώς για το credit.</md>","created":"2024-11-02T13:03:27Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null}],"uid":"m1w5urtwklx4r8","children":[],"tag_good_arr":["llz2dt5jij45lu"],"id":"m306ca67kxb1of","updated":"2024-11-03T08:16:33Z","config":{"editor":"md"}}],"tag_good_arr":["llz2dt5jij45lu","m1w5urtwklx4r8","lndeeow72a32qc","m1qlywwup4r3vy"],"no_answer":0,"id":"m2z1s7dpw4h6g3","d-bucket":"Yesterday","updated":"2024-11-02T16:08:23Z","config":{"editor":"md"}}],"tag_good_arr":["m1p1n3z3mo7eo"],"anon_icons":true,"id":"m2y85khan9b7jg","config":{"bypass_email":1,"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":7,"num_favorites":1,"my_favorite":false,"is_bookmarked":true,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372123375,"default_anonymity":"no","my_post":true},"error":null,"aid":"mev6m3toxtj4ah"}