{"result":{"history_size":8,"folders":["extracurricular"],"nr":147,"data":{"embed_links":[]},"created":"2024-12-02T19:26:22Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47f89ak8195ur","v":"all","type":"create","when":"2024-12-02T19:26:22Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47f91ow5t798","v":"all","type":"update","when":"2024-12-02T19:26:59Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47fbo3upib4ao","v":"all","type":"update","when":"2024-12-02T19:29:01Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47ksmykulj3ha","v":"all","type":"update","when":"2024-12-02T22:02:11Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47kvhf6671im","v":"all","type":"update","when":"2024-12-02T22:04:23Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47kyutxhl7l9","v":"all","type":"update","when":"2024-12-02T22:07:01Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47kzjhxnr1q2","v":"all","type":"update","when":"2024-12-02T22:07:33Z"},{"anon":"no","uid":"lea6wbu4cp27bl","data":"m47l0b4go6637z","v":"all","type":"update","when":"2024-12-02T22:08:09Z"},{"anon":"stud","uid":"lnoa0ht4ejk3ns","to":"m47f89acq445uo","type":"followup","when":"2024-12-28T22:18:51Z","cid":"m58qu808cpco7","uid_a":"a_0"},{"anon":"no","uid":"lea6wbu4cp27bl","to":"m47f89acq445uo","type":"feedback","when":"2024-12-28T23:56:00Z","cid":"m58ub62ihr858k"},{"anon":"stud","uid":"lnoa0ht4ejk3ns","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T08:52:10Z","cid":"m59dgo8enf02qp","uid_a":"a_0"},{"anon":"no","uid":"lea6wbu4cp27bl","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T09:30:02Z","cid":"m59etdjkl3p1ji"},{"anon":"stud","uid":"lnoa0ht4ejk3ns","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T09:39:47Z","cid":"m59f5wng1gg6ej","uid_a":"a_0"},{"anon":"no","uid":"lea6wbu4cp27bl","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T09:41:43Z","cid":"m59f8e6ca1x88"},{"anon":"stud","uid":"lnoa0ht4ejk3ns","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T11:17:00Z","cid":"m59imxmrcwc2ep","uid_a":"a_0"},{"anon":"no","uid":"lea6wbu4cp27bl","to":"m47f89acq445uo","type":"feedback","when":"2024-12-29T11:21:06Z","cid":"m59is79z99h75p"}],"bucket_name":"Today","history":[{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T22:08:09Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T22:07:33Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T22:07:01Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T22:04:23Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T22:02:11Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T19:29:01Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; \n\nΈστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. \n\nΔοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T19:26:59Z","content":"<md>Στη θεωρία έχουμε δει δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; Έστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. Δοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"},{"anon":"no","uid":"lea6wbu4cp27bl","subject":"Άσκηση: Διαφορά πίνακα με δυναμικό πίνακα (δείκτη)","created":"2024-12-02T19:26:22Z","content":"<md>Στη θεωρία έχουμε δεί δύο τρόπους να φτιάχνουμε \"πίνακες\".\n\n1. Μπορούμε να δηλώσουμε έναν πίνακα από N ints με τον εξής τρόπο:\n```\nint array[N];\n```\n2. Επίσης μπορούμε να δημιουργήσουμε δυναμικούς πίνακες:\n```c\nint *array = malloc(N * sizeof(int));\n```\nΣτα προγράμματα που έχετε δει μέχρι τώρα (ενδεχομένως) η συμπεριφορά των δύο\nείναι φαινομενικά η ίδια, δηλαδή τα παρακάτω πρόγραμματα δουλεύουν και στις δύο περιπτώσεις πινάκων:\n- Με χρήση `[]`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    array[i] = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", array[j]);\n}\n```\n- Με χρήση `*`:\n```\nfor (int i = 0 ; i < N ; ++i) {\n    *(array + i) = i;\n}\nfor (int j = 0 ; j < N ; ++j) {\n    printf(\"%d\\n\", *(array + j));\n}\n```\nΆρα ο πίνακας φαίνεται να δουλεύει σαν δείκτης, και ο δυναμικός πίνακας (που είναι δείκτης) μπορεί να λειτουργήσει και σαν πίνακας.\n\nΑς δούμε τώρα ένα πρόβλημα που θα συναντήσετε σίγουρα: Πως μπορώ να περάσω σαν όρισμα\nσυνάρτησης έναν πίνακα; Έστω ότι θέλω να περάσω στη συνάρτηση `foo` έναν πίνακα από 10\nints, μια υλοποίηση είναι:\n```c\nvoid foo(int array[10]) {\n    ...\n}\n```\nΜπορείτε όμως και μόνοι σας να επιβεβαίωσετε πως και οι παρακάτω τρόποι είναι σωστοί:\n```c\nvoid foo(int array[]) {\n    ...\n}\n\nvoid foo(int *array) {\n    ...\n}\n```\nΔοκιμάστε και τους 3 τρόπους στο ακόλουθο πρόγραμμα πειράζοντας το όρισμα της `foo`:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    foo(array);\n    return 0;\n}\n```\nΤο ενδιαφέρον είναι ότι αν αλλάξετε τον πίνακα σε δυναμικό τότε θα παρατηρήσετε\nότι η συνάρτηση πάλι δουλέυει και με τους 3 τρόπους. Δοκιμάστε πάλι να αλλάξετε\nτο όρισμα της `foo` στο πρόγραμμα:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// void foo(int *array) {\n// void foo(int array[]) {\nvoid foo(int array[10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        printf(\"%d\\n\", array[i]);\n    }\n}\n\nint main(void) {\n    int *array = malloc(10 * sizeof(int));\n    for (int i = 0 ; i < 10 ; ++i) {\n        array[i] = i + 1;\n    }\n    foo(array);\n    return 0;\n}\n```\n\nΚαλά όλα αυτά αλλά τι έχουν να κάνουν με τη διαφορά πίνακα και του δυναμικού πίνακα; Ας δούμε ένα πιο προχωρημένο παράδειγμα:\n\nΥλοποιείστε μια συνάρτηση η οποία να παίρνει σαν όρισμα έναν δισδιάστατο 10x10 πίνακα και να τον τυπώνει.\n\nΜια τέτοια συνάρτηση είναι η:\n```c\nvoid foo(int array[10][10]) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n```\nΑν όμως πάμε να κάνουμε κάποιον άλλο τρόπο από αυτούς που είδαμε πριν,\nδεν δουλεύει το πρόγραμμα όπως θα περιμέναμε:\n```c\n/* file: test.c */\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid foo(int **array) {\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            printf(\"%d\\n\", array[i][j]);\n        }\n    }\n}\n\nint main(void) {\n    int array[10][10];\n    for (int i = 0 ; i < 10 ; ++i) {\n        for (int j = 0 ; j < 10 ; ++j) {\n            array[i][j] = i * 10 + j;\n        }\n    }\n    foo(array);\n    return 0;\n}\n```\n- Ενδεικτική εκτέλεση στο `linux12`:\n```\n0:linux12:~> gcc test.c -o test\ntest.c: In function ‘main’:\ntest.c:19:9: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]\n   19 |     foo(array);\n      |         ^~~~~\n      |         |\n      |         int (*)[10]\ntest.c:4:16: note: expected ‘int **’ but argument is of type ‘int (*)[10]’\n    4 | void foo(int **array) {\n      |          ~~~~~~^~~~~\n0:linux12:~> ./test\nSegmentation fault (core dumped)\n139:linux12:~>\n```\n\nΚαλείστε να απαντήσετε στα ακόλουθα ερωτήματα:\n1. Τι θέλει να μας πεί ο compiler με το warning `incompatible pointer type`;\n2. Γιατί το πρόγραμμα απέτυχε και έβγαλε το λάθος `Segmentation fault (core dumped)`;\n3. Μπορώ να χρησιμοποίησω τελικά `*` ή `[]` στο όρισμα της συνάρτησης; Αν ναι\nνα δώσετε κάποιο παράδειγμα και να δικαιολογήσετε γιατί δουλεύει. Αν όχι\nνα εξηγήσετε γιατί δεν μπορεί να γίνει κάτι τέτοιο.\n4. Αν αντί για πίνακα είχατε δυναμικό πίνακα τότε πώς θα ορίζατε την συνάρτηση\nπέρα από `void foo(int **array)`; Μπορείτε να χρησιμοποιήσετε `[10]` ή `[]`;</md>"}],"type":"note","anon_map":{"lnoa0ht4ejk3ns":"a_0"},"tags":["extracurricular","instructor-note"],"tag_good":[{"role":"ta","name":"Stathis Konstantinou","endorser":{},"admin":true,"photo":"f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","id":"lndeeow72a32qc","photo_url":"https://cdn-uploads.piazza.com/photos/lndeeow72a32qc/f4b1c569-2ad2-4c63-a1fe-fc3ddde49fa9_200.jpg","published":true,"email":"sdi2300099@di.uoa.gr","us":false,"admin_permission":5,"facebook_id":null},{"role":"student","name":"Stavros Skaltsas","endorser":{},"admin":false,"photo":null,"id":"m1p1n3z3mo7eo","photo_url":null,"published":true,"email":"sdi2400180@di.uoa.gr","us":false,"facebook_id":null}],"unique_views":119,"children":[{"anon":"stud","folders":[],"data":null,"no_upvotes":0,"subject":"Αν δεν ξεραμεε το ποσα στοιχεια εχει μεσα ο πινακας,πως  θα μπορουσαμε να φτιαξουμε τους πινακες των παραπανω παραδειγματων;","created":"2024-12-28T22:18:51Z","bucket_order":3,"bucket_name":"Today","type":"followup","tag_good":[],"uid":"lnoa0ht4ejk3ns","uid_a":"a_0","children":[{"anon":"no","folders":[],"data":null,"subject":"<md>Δεν είμαι σίγουρος ότι καταλαβαίνω την ερώτηση.. εννοείς πως θα μπορούσαμε να φτιάξουμε δυναμικούς πίνακες με size ορισμένο από user input?</md>","created":"2024-12-28T23:56:00Z","bucket_order":4,"bucket_name":"Yesterday","type":"feedback","tag_good":[],"uid":"lea6wbu4cp27bl","children":[],"tag_good_arr":[],"id":"m58ub62ihr858k","d-bucket":"Yesterday","updated":"2024-12-28T23:56:00Z","config":{"editor":"md"}},{"anon":"stud","folders":[],"data":null,"subject":"<p>ακριβως,δηλαδη να φτιαχναμε εναν πινακα αναλογα με τα στοιχεια που θα εβαζε ο χρηστης και αν χρειαζοταν να μεγαλωσει ο πινακας πως θα χρησιμοποιουσαμε την malloc.</p>\n<p></p>","created":"2024-12-29T08:52:10Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lnoa0ht4ejk3ns","uid_a":"a_0","children":[],"tag_good_arr":[],"id":"m59dgo8enf02qp","updated":"2024-12-29T08:52:10Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Κάτι τέτοιο ψάχνεις?\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) return 1;\n    int n = atoi(argv[1]);\n    if (n <= 0) return 1;\n\n    /* Dynamic array from user input */\n    int *array = malloc(n * sizeof(int));\n\n    /* Expand array to twice its size */\n    array = realloc(array, 2 * n * sizeof(int));\n\n    /* Cleanup */\n    free(array);\n    return 0;\n}\n```\nΊσως αν μου έλεγες τι το θες να μπορούσα να βοηθήσω παραπάνω</md>","created":"2024-12-29T09:30:02Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lea6wbu4cp27bl","children":[],"tag_good_arr":[],"id":"m59etdjkl3p1ji","updated":"2024-12-29T09:34:06Z","config":{"editor":"md"}},{"anon":"stud","folders":[],"data":null,"subject":"Ακριβως,βεβαια αν δεν παιρναμε  args απτην main θα μπορουσαμε να το κανουμε και αλλιως;","created":"2024-12-29T09:39:47Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lnoa0ht4ejk3ns","uid_a":"a_0","children":[],"tag_good_arr":[],"id":"m59f5wng1gg6ej","updated":"2024-12-29T09:39:47Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<md>Το n το παίρνεις από όπου θες, stdin, αρχείο, args, ότι σε βολεύει, δεν αλλάζει κάτι....</md>","created":"2024-12-29T09:41:43Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lea6wbu4cp27bl","children":[],"tag_good_arr":[],"id":"m59f8e6ca1x88","updated":"2024-12-29T09:41:43Z","config":{"editor":"md"}},{"anon":"stud","folders":[],"data":null,"subject":"ειναι πιο σωστο δηλαδη να δηλωνουμε τον πινακα με το int *arr και να φτιαχνουμε το size αναλογα με το input που θα βαλει ο χρηστης απτο να το δηλωνουμε με int arr[];","created":"2024-12-29T11:17:00Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lnoa0ht4ejk3ns","uid_a":"a_0","children":[],"tag_good_arr":[],"id":"m59imxmrcwc2ep","updated":"2024-12-29T11:17:00Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"<md>αν δεν βάλεις size μέσα στο `[]` (δηλαδή `[n]`) τότε είναι ακριβώς το ίδιο, όπως και στο argv με τα `char **argv` και `char *argv[]`. Τώρα αν βάλεις το n μέσα, δηλαδή ορίσεις έναν πίνακα `int array[n]` όπου το n εξαρτάται από user input τότε συγχαρητήρια έχεις φτιάξει ενα VLA (variable length array), αυτή είναι μια πολύ σκοτεινή γωνία της C που καλύτερα να μην την ακουμπήσεις ποτέ :)\n\ntl;dr βάλε `[]` ή `*` το ίδιο είναι, μακριά όμως από `[n]`.</md>","created":"2024-12-29T11:21:06Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[],"uid":"lea6wbu4cp27bl","children":[],"tag_good_arr":[],"id":"m59is79z99h75p","updated":"2024-12-29T11:21:06Z","config":{"editor":"md"}}],"tag_good_arr":[],"no_answer":0,"id":"m58qu808cpco7","updated":"2024-12-29T11:21:06Z","config":{"editor":"rte"}}],"tag_good_arr":["m1p1n3z3mo7eo","lndeeow72a32qc"],"anon_icons":true,"id":"m47f89acq445uo","config":{"editor":"md","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":3,"num_favorites":2,"my_favorite":false,"is_bookmarked":false,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756372255302,"default_anonymity":"no"},"error":null,"aid":"mev6oxmfdh434m"}