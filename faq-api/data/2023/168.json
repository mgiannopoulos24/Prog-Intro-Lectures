{"result":{"history_size":1,"folders":["projecteuler"],"nr":168,"data":{"embed_links":[]},"created":"2023-11-03T17:57:36Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"llz2dt5jij45lu","data":"loix4mhmr8n277","v":"all","type":"create","when":"2023-11-03T17:57:36Z"},{"anon":"no","uid":"llz2dt5jij45lu","data":"loix5ib9uac597","to":"loix4mhitmn276","type":"i_answer","when":"2023-11-03T17:58:17Z"},{"anon":"no","uid":"lne9owv6pcm1tq","data":"loixdfc0t95vx","to":"loix4mhitmn276","type":"s_answer","when":"2023-11-03T18:04:26Z"},{"anon":"no","uid":"lne9owv6pcm1tq","data":"loixgcbqtf843v","type":"s_answer_update","when":"2023-11-03T18:06:43Z"},{"anon":"no","uid":"lne9owv6pcm1tq","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T18:07:01Z","cid":"loixgq7no8o4r4"},{"anon":"no","uid":"lne9owv6pcm1tq","data":"loixjapkbgb21b","type":"s_answer_update","when":"2023-11-03T18:09:00Z"},{"anon":"no","uid":"lneblllqeew3dc","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T18:22:41Z","cid":"loiy0vr4usf25u"},{"anon":"no","uid":"lne9owv6pcm1tq","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T18:24:40Z","cid":"loiy3fcd51v3ra"},{"anon":"no","uid":"ln8xs3nvi166oe","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T19:05:53Z","cid":"loizkfso6m64ei"},{"anon":"no","uid":"ln8vhq78iwc4me","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T19:12:27Z","cid":"loizsviqiqs79z"},{"anon":"no","uid":"ln8vk6gs96f6z5","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T19:22:46Z","cid":"loj065meylq1yv"},{"anon":"no","uid":"lne7to1q2jw37a","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T19:55:16Z","cid":"loj1byhajy9m1"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:15:32Z","cid":"loj2201khoo260"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:16:45Z","cid":"loj23l286x7654"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:17:43Z","cid":"loj24tpvwup1c1"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:18:39Z","cid":"loj260fefl53zx"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:20:35Z","cid":"loj28i7s2oi2bp"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:27:11Z","cid":"loj2gzr1mpz7ko"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"followup","when":"2023-11-03T20:33:02Z","cid":"loj2oif2ydv1r1"},{"anon":"no","uid":"ln8vk6gs96f6z5","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:40:28Z","cid":"loj2y2cffqd5pa"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-03T20:42:55Z","cid":"loj3182uiwkor"},{"anon":"stud","uid":"leett90qgwp2d1","to":"loix4mhitmn276","type":"feedback","when":"2023-11-04T00:48:38Z","cid":"lojbt86w8ah1eg","uid_a":"a_0"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-04T04:20:55Z","cid":"lojje7slxjwlw"},{"anon":"no","uid":"ln91i6dufku7pi","to":"loix4mhitmn276","type":"feedback","when":"2023-11-04T08:02:16Z","cid":"lojravke4zd1ha"},{"anon":"no","uid":"lneblllqeew3dc","to":"loix4mhitmn276","type":"followup","when":"2023-11-05T11:06:12Z","cid":"loldb9u6x9q74k"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-06T06:30:04Z","cid":"lomiw0fj2jc6q0"},{"anon":"no","uid":"lneblllqeew3dc","to":"loix4mhitmn276","type":"followup","when":"2023-11-06T07:18:10Z","cid":"lomklv02kh67ci"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-06T10:05:29Z","cid":"lomql19iedo2on"},{"anon":"no","uid":"lne7to1q2jw37a","to":"loix4mhitmn276","type":"followup","when":"2023-11-06T23:19:33Z","cid":"loniy7h2w7r4j4"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-07T03:55:42Z","cid":"lonstcqjqq22gu"},{"anon":"no","uid":"lne7to1q2jw37a","to":"loix4mhitmn276","type":"feedback","when":"2023-11-07T09:12:56Z","cid":"loo45ayprcv7bx"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-07T10:47:37Z","cid":"loo7j2hy7odd"},{"anon":"no","uid":"lne7to1q2jw37a","to":"loix4mhitmn276","type":"followup","when":"2023-11-08T21:45:22Z","cid":"loqagsepaya104"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-09T12:25:07Z","cid":"lor5w61ohbm63o"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"followup","when":"2023-11-10T14:59:35Z","cid":"losqunyjx3e5r6"},{"anon":"no","uid":"lne7to1q2jw37a","to":"loix4mhitmn276","type":"followup","when":"2023-11-10T20:17:35Z","cid":"lot27lqeam56gw"},{"anon":"no","uid":"llz2dt5jij45lu","to":"loix4mhitmn276","type":"feedback","when":"2023-11-12T05:20:15Z","cid":"lov11cfj3n72t0"}],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"Σπαζοκεφαλιά για δυνατούς λύτες","created":"2023-11-03T17:57:36Z","content":"<p>Καλησπέρα,</p>\n<p></p>\n<p>Σήμερα το πρωί μιλήσαμε για πίνακες και περιγράψαμε κάποιες μεθόδους για το πως να τους διασχίζουμε και να υπολογίζουμε την τιμή που χρειαζόμαστε για κάποιες περιπτώσεις (μέσο όρο, εύρεση στοιχείου κτλ). Παρ&#39;όλη την σχετικά &#34;απλή&#34; ιδέα των πινάκων, πολύ συχνά, δύσκολα προβλήματα και δημιουργικές λύσεις μπορούν να ξεπηδήσουν κατά την χρήση τους.</p>\n<p></p>\n<p>Μια σπαζοκεφαλιά με πίνακα που με τυράννησε για *πολλές* μέρες κάποτε ήταν η ακόλουθη:</p>\n<p></p>\n<p>Έστω ότι έχω έναν πίνακα με μέγεθος N&#43;1 και έστω ότι περιέχει όλους τους αριθμούς από το 1 μέχρι το Ν (με τυχαία σειρά) από μία φορά και ένας από αυτούς τους αριθμούς περιέχεται δύο φορές (αναγκαστικά για να γεμίσω Ν&#43;1 θέσεις). Δηλαδή όλοι οι ακέραιοι του πίνακα είναι μοναδικοί, εκτός από έναν. Υπάρχει τρόπος να βρούμε τον αριθμό που εμφανίζεται δύο φορές χωρίς να χρησιμοποιήσουμε πολλή έξτρα μνήμη; (για παράδειγμα αποφεύγοντας να φτιάξουμε άλλον έναν πίνακα;).</p>\n<p></p>\n<p>Για παράδειγμα, για Ν = 100, το πρόβλημα δείχνει ως εξής:<br /><br /></p>\n<pre>\n#include &lt;stdio.h&gt;\n\nint main() {\n\n  int a[101] = {56, 73, 89, 90, 53, 54, 6, 59, 31, 57, 17, 66, 8, 76, 100, 80, 87, 19, 16, 30, 49, 77, 50, 15, 64, 60, 67, 1, 42, 45, 42, 88, 32, 61, 12, 11, 27, 81, 44, 14, 36, 99, 22, 43, 65, 4, 46, 58, 98, 83, 68, 24, 33, 29, 21, 79, 85, 69, 25, 75, 82, 62, 52, 37, 74, 9, 93, 3, 91, 78, 41, 18, 70, 72, 34, 26, 2, 20, 84, 5, 35, 63, 97, 39, 86, 48, 96, 23, 94, 10, 71, 51, 28, 40, 55, 38, 92, 47, 13, 7, 95};\n\n  int duplicate;\n  // find out duplicate without another array\n\n  // print identified duplicate\n  printf(&#34;%d\\n&#34;, duplicate);\n  return 0;\n}</pre>\n<p></p>\n<p>Αυτή το πρόβλημα είναι ιδιαίτερα δύσκολο αν δεν το έχετε ξαναδεί, αλλά αν σας αρέσει να λύνετε σπαζοκεφαλιές στον ελεύθερο χρόνο σας δείτε το ως πρόκληση! Αν δεν σας αρέσουν οι σπαζοκεφαλιές απλά αγνοήστε το :) Αν κάποιος/α έχει ιδέα για το πως θα μπορούσαμε να βρούμε κάποια λύση και γιατί θα λειτουργεί ας το μοιραστεί!</p>\n<p></p>\n<p>Καλό Σαββατοκύριακο,</p>\n<p>Θανάσης</p>"}],"type":"question","anon_map":{"leett90qgwp2d1":"a_0"},"tags":["instructor-question","projecteuler"],"tag_good":[],"unique_views":159,"children":[{"history_size":1,"folders":[],"data":{"embed_links":[]},"created":"2023-11-03T17:58:17Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"","created":"2023-11-03T17:58:17Z","content":"Συζήτηση από κάτω \\/"}],"type":"i_answer","tag_endorse_arr":[],"children":[],"id":"loix5ib5ouh596","config":{"editor":"rte"},"is_tag_endorse":false},{"history_size":3,"folders":[],"data":{"embed_links":[]},"created":"2023-11-03T18:04:26Z","bucket_order":3,"tag_endorse":[],"bucket_name":"Today","history":[{"anon":"no","uid":"lne9owv6pcm1tq","subject":"","created":"2023-11-03T18:09:00Z","content":"."},{"anon":"no","uid":"lne9owv6pcm1tq","subject":"","created":"2023-11-03T18:06:43Z","content":"Για αρχη υπολογιζουμε το αθροισμα των αριθμων απο το 1 μεχρι το N και μετα το αθροισμα ολων των στοιχειων του πινακα [Ν&#43;1] και επειτα αμα βρουμε την διαφορα των δυο αθροισματων (sum[N&#43;1] -sum[1 εως Ν) βρισκουμε τον αριθμο ο οποιος επαναλαμβανεται"},{"anon":"no","uid":"lne9owv6pcm1tq","subject":"","created":"2023-11-03T18:04:26Z","content":"Για αρχη υπολιγιζουμε το αυροισμα των αριθμων απο το 1 μεχρι το N και μετα το αθροισμα ολων των στοιχειων του πινακα [Ν&#43;1] και επειτα αμα βρουμε την διαφορα των δυο αθροισματων (sum[N&#43;1] -sum[1 εως Ν) βρισκουμε τον αριθμο ο οποιος επαναλαμβανεται"}],"type":"s_answer","tag_endorse_arr":[],"children":[],"id":"loixdfbzdfi5vw","config":{},"is_tag_endorse":false},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"Για αρχη υπολογιζουμε το αθροισμα των αριθμων απο το 1 μεχρι το N και μετα το αθροισμα ολων των στοιχειων του πινακα [Ν&#43;1] και επειτα αμα βρουμε την διαφορα των δυο αθροισματων (sum[N&#43;1] -sum[1 εως Ν) βρισκουμε τον αριθμο ο οποιος επαναλαμβανεται","created":"2023-11-03T18:07:01Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[{"role":"student","name":"EFSTATHIOS KONSTANTINOU","endorser":{},"admin":false,"photo":null,"id":"lndeeow72a32qc","photo_url":null,"email":"sdi2300099@di.uoa.gr","us":false,"facebook_id":null}],"uid":"lne9owv6pcm1tq","children":[{"anon":"no","folders":[],"data":null,"subject":"Μου έκανες beta την σπαζοκεφαλιά! Εξαιρετική λύση!","created":"2023-11-03T20:15:32Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj2201khoo260","updated":"2023-11-03T20:15:32Z","config":{"editor":"rte"}}],"tag_good_arr":["lndeeow72a32qc"],"no_answer":0,"id":"loixgq7no8o4r4","updated":"2023-11-05T11:09:10Z","config":{}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"Το άθροισμα από 1 έως Ν υπολογίζεται από το άθροισμα Gauss N(N&#43;1)/2. Ο ζητούμενος αριθμός , άρα, είναι το άθροισμα όλων των όρων του πίνακα μείον του 1 έως N.<div><br /></div><div>k = Sum(1, N&#43;1) - N(N&#43;1)/2</div>","created":"2023-11-03T18:22:41Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[{"role":"student","name":"Dimitris Andreakis","endorser":{},"admin":false,"photo":null,"id":"lne7to1q2jw37a","photo_url":null,"email":"sdi2300008@di.uoa.gr","us":false,"facebook_id":null}],"uid":"lneblllqeew3dc","children":[{"anon":"no","folders":[],"data":null,"subject":"Πολύ σωστά!","created":"2023-11-03T20:16:45Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj23l286x7654","updated":"2023-11-03T20:16:45Z","config":{"editor":"rte"}}],"tag_good_arr":["lne7to1q2jw37a"],"no_answer":0,"id":"loiy0vr4usf25u","updated":"2023-11-03T20:27:22Z","config":{}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"Ναι, το ιδιο πραγμα ειναι απλως με αλλο τυπο","created":"2023-11-03T18:24:40Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[],"uid":"lne9owv6pcm1tq","children":[{"anon":"no","folders":[],"data":null,"subject":"μπορουμε να ταξινομησουμε τον πινακα κατα αυξουσα σειρα και να συγκρινουμε συνεχομενα ζευγη τιμων και μολις βρουμε ενα ολοιδιο τοτε κανουμε break και εκτυπωνουμε την τιμη του αριθμου ","created":"2023-11-03T19:05:53Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[{"role":"student","name":"Konstantinos Xanthopoulos","endorser":{},"admin":false,"photo":null,"id":"ln91i6dufku7pi","photo_url":null,"published":true,"email":"sdi2300146@di.uoa.gr","us":false,"facebook_id":null}],"uid":"ln8xs3nvi166oe","children":[],"tag_good_arr":["ln91i6dufku7pi"],"id":"loizkfso6m64ei","updated":"2023-11-04T07:59:00Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Και η λύση με την ταξινόμηση ολόσωστη! Μόνο που θα μας πάρει λίγο παραπάνω χρόνο (ίσως και χώρο) για να κάνουμε την ταξινόμηση.","created":"2023-11-03T20:17:43Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj24tpvwup1c1","updated":"2023-11-03T20:17:43Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loiy3fcd51v3ra","updated":"2023-11-03T21:52:49Z","config":{}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Πιστεύω είναι μια αξιοπρεπής λύση της σπαζοκεφαλιάς.</p>\n<p style=\"text-align:left\">Χρησιμοποιώ τον πίνακα που δίνετε, τον ταξινομώ σε αύξουσα σειρά και στην συνέχεια συγκρίνω ένα προς ένα τα στοιχεία του.</p>\n<p style=\"text-align:left\">Όταν το προηγούμενο στοιχείο είναι ίσο με το επόμενο τότε ο βρόγχος for σταματάει και εκτυπώνετε η τιμή που ψάχνω.</p>\n<p style=\"text-align:left\"> </p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid bubblesort(int *a);\n\nint main() {\n\n    int a[101] = {56, 73, 89, 90, 53, 54, 6, 59, 31, 57, 17, 66, 8, 76, 100, 80, 87, 19, 16, 30, 49, 77, 50, 15, 64, 60, 67, 1, 42, 45, 42, 88, 32, 61, 12, 11, 27, 81, 44, 14, 36, 99, 22, 43, 65, 4, 46, 58, 98, 83, 68, 24, 33, 29, 21, 79, 85, 69, 25, 75, 82, 62, 52, 37, 74, 9, 93, 3, 91, 78, 41, 18, 70, 72, 34, 26, 2, 20, 84, 5, 35, 63, 97, 39, 86, 48, 96, 23, 94, 10, 71, 51, 28, 40, 55, 38, 92, 47, 13, 7, 95};\n\n    int duplicate=a[0];\n    \n    //Bubblesort σε αύξουσα σειρά\n    bubblesort(a);\n    \n    //Διαπέραση του πίνακα\n    for(int i=1;i&lt;101;i&#43;&#43;){\n        if(duplicate!=a[i])\n            duplicate=a[i];\n        else \n            break;\n    }\n\n    //Εκτύπωση αριθμού\n    printf(&#34;%d\\n&#34;, duplicate);\n    return 0;\n}\n\nvoid bubblesort(int *a) \n{\n    int i, j;\n    for (i = 0; i &lt; 101 - 1; i&#43;&#43;) {\n        for (j = 0; j &lt; 101 - i - 1; j&#43;&#43;) {\n            if (a[j] &gt; a[j &#43; 1]) {\n                int temp = a[j];\n                a[j] = a[j &#43; 1];\n                a[j &#43; 1] = temp;\n            }\n        }\n    }\n}</pre>","created":"2023-11-03T19:12:27Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[],"uid":"ln8vhq78iwc4me","children":[{"anon":"no","folders":[],"data":null,"subject":"Ολόσωστη και αυτή η λύση! Μπορούμε να το κάνουμε και χωρίς την ταξινόμηση;","created":"2023-11-03T20:18:39Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj260fefl53zx","updated":"2023-11-03T20:18:39Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loizsviqiqs79z","updated":"2023-11-03T20:18:39Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Εφόσον ο πίνακας είναι γεμάτος με αριθμούς από το 1 έως το Ν, πράγματι η μέθοδος των αθροισμάτων φαίνεται να είναι η βέλτιστη.</p>\n<p>Στην περίπτωση όμως που ο πίνακας είναι γεμάτος με τυχαίους αριθμούς μία προσέγγιση είναι η εξής:</p>\n<div>\n<pre>\nfor(i=0; i&lt;Ν; i&#43;&#43;)\n  {\n      for(j=i; j&lt;Ν; j&#43;&#43;)\n     {\n          if(a[i]==a[j] &amp;&amp; i!=j)\n          {\n            printf(&#34;%d&#34;, a[i]);\n            goto end;\n          }\n     }\n  }\n  end:</pre>\n</div>","created":"2023-11-03T19:22:46Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[],"uid":"ln8vk6gs96f6z5","children":[{"anon":"no","folders":[],"data":null,"subject":"Δυνατή λύση χωρίς καθόλου καινούριες μεταβλητές! Αν δεν είχες και το goto θα ήταν η αγαπημένη μου ;)  (αστειεύομαι, στην προκειμένη ίσως είναι από τις λίγες χρήσεις goto που έχει νόημα)","created":"2023-11-03T20:20:35Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj28i7s2oi2bp","updated":"2023-11-03T20:20:35Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loj065meylq1yv","updated":"2023-11-03T20:27:18Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Στην πράξη, η λύση με τα αθροίσματα:</p>\n<p></p>\n<pre>\n#include &lt;stdio.h&gt;\nint Sum(int a[], int N){\n\tint sum=0;\n\tfor(int i=0; i&lt;N&#43;1; &#43;&#43;i) sum&#43;=a[i];\n\treturn sum;\n}\nint main(){\n\tint a[101] = {56, 73, 89, 90, 53, 54, 6, 59, 31, 57, 17, 66, 8, 76, 100, 80, 87, 19, 16, 30, 49, 77, 50, 15, 64, 60, 67, 1, 42, 45, 42, 88, 32, 61, 12, 11, 27, 81, 44, 14, 36, 99, 22, 43, 65, 4, 46, 58, 98, 83, 68, 24, 33, 29, 21, 79, 85, 69, 25, 75, 82, 62, 52, 37, 74, 9, 93, 3, 91, 78, 41, 18, 70, 72, 34, 26, 2, 20, 84, 5, 35, 63, 97, 39, 86, 48, 96, 23, 94, 10, 71, 51, 28, 40, 55, 38, 92, 47, 13, 7, 95};\n\tint N=sizeof(a)/sizeof(a[0]) - 1;\n\tint duplicate= Sum(a, N) - N*(N&#43;1)/2;\n\tprintf(&#34;%d\\n&#34;, duplicate);\n\treturn 0;\n}</pre>","created":"2023-11-03T19:55:16Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[],"uid":"lne7to1q2jw37a","children":[{"anon":"no","folders":[],"data":null,"subject":"Τέλεια, μια γραμμική σε λύση χρόνο! Μικρό στυλιστικό: συνήθως τις συναρτήσεις τις ξεκινάμε με μικρά γράμματα (lowercase).","created":"2023-11-03T20:27:11Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj2gzr1mpz7ko","updated":"2023-11-03T20:27:11Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loj1byhajy9m1","updated":"2023-11-03T20:27:11Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"Τι θα κάνατε αν αντί για *ακριβώς ένα* στοιχείο που να εμφανίζεται δύο φορές, υπήρχε *τουλάχιστον ένα* ή και παραπάνω στοιχεία που εμφανίζονται πολλές φορές και πρέπει απλά να γυρίσουμε ένα από αυτά; Πως θα εντοπίζαμε τα διπλά στοιχεία αποδοτικά; Το διπλό for-loop όπως και η ταξινόμηση δουλεύουν αλλά παίρνουν λίγο παραπάνω χρόνο. Δουλεύει ακόμα ο τύπος με το άθροισμα; Υπάρχει λύση που να είναι γραμμική σε χρόνο (δηλαδή όχι εμφωλευμένα for loop) και να μην απαιτεί περισσότερο χώρο μνήμης;","created":"2023-11-03T20:33:02Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"followup","tag_good":[],"uid":"llz2dt5jij45lu","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>Θα μπορούσαμε να δημιουργήσουμε έναν πίνακα μήκους Ν που θα αποθηκεύεται η συχνότητα κάθε αριθμού. Αν βρίσκαμε έστω και ένα κελί με συχνότητα μεγαλύτερη του 1 θα ήμασταν τελειωμένοι. Με τέτοια περίπου υλοποίηση: </p>\n<pre>\nfor(i=0; i&lt;Ν; i&#43;&#43;)\n  {\n      count[a[i]]&#43;&#43;;\n  }</pre>\n<p>Στην περίπτωση αυτή το a[i] λειτουργεί σαν &#39;δείκτης&#39;.</p>\n<p>Η λύση έχει ως προαπαιτούμενο ότι οι αριθμοί είναι μικρότεροι του Ν</p>\n<p>Επίσης ο πίνακας count πρέπει να μηδενιστεί πριν ξεκινήσει το for </p>","created":"2023-11-03T20:40:27Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"ln8vk6gs96f6z5","children":[],"tag_good_arr":[],"id":"loj2y2cffqd5pa","updated":"2023-11-03T20:41:08Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Και αυτή η λύση δουλεύει! Αλλά μας τρώει έξτρα χώρο (Ν στοιχεία) ο πίνακας count :(","created":"2023-11-03T20:42:55Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loj3182uiwkor","updated":"2023-11-03T20:42:55Z","config":{"editor":"rte"}},{"anon":"stud","folders":[],"data":null,"subject":"θα μπορουσαμε ενδεχωμένως μια αναδρομή ; ξεκινώντας απο το πρωτο στοιχείο να ψάχνει όλα τα υπόλοιπα κάνοντας συγκρισεις, αν δεν βρει τίποτα θα καλει τον εαυτο της με πχ i&#43;&#43; <br />Η αυτό βγαίνει σε πολυπλοκότητα όσο πάλι τα 2 for loops ?","created":"2023-11-04T00:48:38Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"leett90qgwp2d1","uid_a":"a_0","children":[],"tag_good_arr":[],"id":"lojbt86w8ah1eg","updated":"2023-11-04T00:48:38Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Δεν είμαι σίγουρος αλλά αν όντως για κάθε ένα στοιχείο χρειάζεται να κάνεις σύγκριση με ένα άλλο στοιχείο τότε ίσως να είναι ισοδύναμο με δύο for loops.","created":"2023-11-04T04:20:55Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"lojje7slxjwlw","updated":"2023-11-04T04:20:55Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Η αναδρομη παντα αργη ειναι οποτε δεν νομιζω πως συμφερει.","created":"2023-11-04T08:02:16Z","bucket_order":8,"bucket_name":"Week 10/29 - 11/4","type":"feedback","tag_good":[],"uid":"ln91i6dufku7pi","children":[],"tag_good_arr":[],"id":"lojravke4zd1ha","updated":"2023-11-04T08:02:16Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loj2oif2ydv1r1","updated":"2023-11-04T08:02:16Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"Ένας τρόπος να πετύχουμε γραμμική πολυπλοκότητα, είναι να αντιμετωπίσουμε το κάθε στοιχείο του πίνακα ως δείκτη του εαυτού του. Το arr[arr[i]] μας στέλνει στην θέση arr[i]. Κάθε φορά που βρίσκουμε έναν θετικό αριθμό , τον κάνουνε αρνητικό ή μηδέν (ότι μας βολεύει). Έτσι αν όλα τα στοιχεία ήταν μοναδικά, κάθε στοιχείο θα μας έστελνε σε μοναδική, θετική θεση στον πίνακα. Αμα όμως καταλήξουμε σε προηγούμενο αρνητικό ή μηδέν, το στοιχείο στη θέση i είναι επαναλαμβανόμενο.","created":"2023-11-05T11:06:12Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[],"uid":"lneblllqeew3dc","children":[{"anon":"no","folders":[],"data":null,"subject":"Νομίζω πως είσαι πολύ κοντά σε μια λύση Κωνσταντίνε - το δοκίμασες να το μεταφράσεις σε κώδικα να δεις αν παίζει;","created":"2023-11-06T06:30:04Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"lomiw0fj2jc6q0","updated":"2023-11-06T06:30:04Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loldb9u6x9q74k","updated":"2023-11-06T06:30:04Z","config":{}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p></p>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint arr[16] = {1, 3, 4, 5, 6, 8, 8, 9, 1, 10, 10, 11, 11, 12, 13, 12};\nconst unsigned int arrsize = sizeof(arr)/sizeof(arr[0]);\n\nint main() {\n    for (int i = 0; i &lt; arrsize; i&#43;&#43;) {\n        int element = abs(arr[i]);\n\n        if (arr[element] &gt; 0) {\n            arr[element] *= -1;\n        } else {\n            if (element != arrsize) {\n                printf(&#34;%d\\n&#34;, element);\n            }\n        }\n    }\n}</pre>\n<p>Output: 8,1,10,11,12</p>\n<p></p>\n<p>Αυτό νομίζω πρέπει να λειτουργεί!</p>","created":"2023-11-06T07:18:10Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[],"uid":"lneblllqeew3dc","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>Μου φαίνεται ολόσωστη! Μπράβο! Μια γραμμική σε χρόνο λύση που δεν χρησιμοποιεί καθόλου έξτρα μνήμη!</p>\n<p></p>\n<p>Αυτό κάνει unlock και το τελευταίο επίπεδο: η παραπάνω λύση πετυχαίνει αυτό που θέλουμε, αλλά γράφει πάνω στα στοιχεία του πίνακα για να κρατήσει το state. Ερώτηση: είναι δυνατό να γίνει κάτι τέτοιο χωρίς να γράψουμε στον πίνακα - μόνο με διάβασμα των στοιχείων του; Διατηρώντας την γραμμική πολυπλοκότητα και χωρίς να δημιουργήσουμε άλλον πίνακα;</p>","created":"2023-11-06T10:05:29Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"lomql19iedo2on","updated":"2023-11-06T10:05:29Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"lomklv02kh67ci","updated":"2023-11-06T10:05:37Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Μια λύση για πολλούς επαναλαμβανόμενους αριθμούς, με γραμμική πολυπλοκότητα, χωρίς επιπλέον πίνακα και χωρίς ταξινόμηση:<br /><br /></p>\n<pre>\n#include &lt;stdio.h&gt;\n\nvoid duplicates(int a[], int n){\n\n\t//Για κάθε στοιχείο του πίνακα, αυξάνεται η θέση &#34;στοιχείο&#34; κατά n.\n\t//Οι θέσεις που θα έχουν αυξηθεί θα είναι και τα υπάρχοντα στοιχεία του πίνακα.\n\t//Όμως, στους διπλούς αριθμούς, η θέση αυξάνεται πάνω από μία φορά (τουλάχιστον 2)\n\tfor (int i = 0; i &lt; n; i&#43;&#43;) {\n\t\tint thesi = a[i]%n;\n\t\ta[thesi] &#43;= n;\n\t}\n\n\t//Αν κάποια θέση έχει αυξηθεί τουλάχιστον 2 φορές (θέση/n&gt;=2),\n\t//αντιστοιχεί σε διπλό αριθμό\n\tfor (int i = 0; i &lt; n; i&#43;&#43;){\n\t\tif ((a[i] / n) &gt;= 2) printf(&#34;%d &#34;, i);\n\t\t//Το floor(a[i]/n), μάλιστα, δίνει και πόσες φορές υπάρχει ο αριθμός\n\t}\n}\n\n\nint main(){\n\tint a[101] = {56, 73, 89, 90, 53, 54, 6, 59, 31, 57, 17, 66, 8, 76, 100, 80, 87, 19, 16, 30, 49, 77, 50, 15, 73, 60, 67, 1, 42, 45, 42, 88, 32, 61, 12, 11, 99, 81, 44, 14, 36, 99, 22, 43, 65, 4, 46, 58, 98, 83, 68, 24, 33, 29, 21, 79, 85, 69, 25, 75, 82, 62, 52, 37, 74, 9, 93, 3, 91, 78, 41, 18, 70, 72, 34, 26, 2, 20, 84, 5, 35, 63, 97, 39, 86, 48, 96, 23, 94, 10, 71, 51, 28, 40, 55, 38, 92, 47, 13, 7, 95};\n\tint n = sizeof(a) / sizeof(a[0]);\n \n \tduplicates(a, n);\n\treturn 0;\n}</pre>\n<p></p>\n<p>*Η λύση με τα αθροίσματα δουλέυει μέχρι και για 2 επαναλαμβανόμενους αριθμούς, έστω Χ και Ψ που για να τους βρούμε αρκεί να ξέρουμε το Χ&#43;Ψ (υπολογίζεται εύκολα με μία αφαίρεση) και το Χ-Ψ (υπολογίζεται ως sqrt((X&#43;Y)<sup>2</sup> – 4*XY και προφανώς θα πρέπει να βρόυμε το γινόμενό τους πρώτα (υπολογίζεται εύκολα με μία διαίρεση). Για περισσότερους από 2 αριθμούς, τα αθροίσματα δεν θα μας βοηθήσουν.</p>","created":"2023-11-06T23:19:33Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[],"uid":"lne7to1q2jw37a","children":[{"anon":"no","folders":[],"data":null,"subject":"Άλλη μια δυνατή λύση!! Ρίξε μια ματιά και στην <a href=\"/class/llz2bkutusi4ap/post/168_f9\" target=\"_blank\" rel=\"noopener noreferrer\">παραπάνω</a> που εκμεταλλεύεται τον χώρο του πίνακα κατά λίγο διαφορετικό τρόπο. Το επόμενο επίπεδο είναι: μπορούμε να βρούμε ένα από τα διπλά στοιχεία χωρίς να αλλάξουμε τον πίνακα;","created":"2023-11-07T03:55:42Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"lonstcqjqq22gu","updated":"2023-11-07T03:55:42Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Χωρίς να αλλάξουμε τον πίνακα, να βρεθεί μόνο ένας αριθμός από αυτούς που επαναλαμβάνεται ή όλοι, όπως κάναμε πιο πάνω;","created":"2023-11-07T09:12:56Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"lne7to1q2jw37a","children":[],"tag_good_arr":[],"id":"loo45ayprcv7bx","updated":"2023-11-07T09:12:56Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"subject":"Ας πούμε ένας αριθμός!","created":"2023-11-07T10:47:37Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"id":"loo7j2hy7odd","updated":"2023-11-07T10:47:37Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loniy7h2w7r4j4","updated":"2023-11-07T10:47:37Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Για να βρεθεί ένας αριθμός που επαναλαμβάνεται, ανάμεσα σε πολλούς διπλούς, θεωρώ πως είναι αδύνατο να γνωρίζουμε ποιον αριθμό έχουμε ήδη προσπελάσει χωρίς να χρησιμοποιήσουμε έναν ακόμα πίνακα, ώστε να αποφύγουμε εμφωλευμένες επαναλήψεις.<br />Αν θελήσουμε να αποφύγουμε τον πίνακα, νομίζω πως η μεταβολή κάποιου στοιχείου του πίνακα είναι μονόδρομος. Μπορούμε να μηδενίζουμε τη θέση ενός αριθμό που έχουμε ήδη υπολογίσει και αργότερα, αν εξετάσουμε μια μηδενική θέση, ο διπλός αριθμός είναι σε αυτή τη θέση. Ο κώδικας:<br /><br /></p>\n<pre>\n#include &lt;stdio.h&gt;\n\nint first(int a[], int N){\n    for (int i = 0; i &lt; N; i&#43;&#43;){\n        if (a[a[i]] == 0) return a[i];\n        else a[a[i]]=0;\n    }\n}\n\nint main(){\n    int a[101] = {56, 73, 8, 73, 56, 54, 90, 59, 31, 57, 17, 66, 8, 76, 100, 80, 87, 19, 16, 30, 49, 77, 50, 15, 64, 60, 67, 1, 42, 45, 42, 88, 32, 61, 12, 11, 27, 81, 44, 14, 36, 99, 22, 43, 65, 4, 46, 58, 98, 83, 68, 24, 33, 29, 21, 79, 85, 69, 25, 75, 82, 62, 52, 37, 74, 9, 93, 3, 91, 78, 41, 18, 70, 72, 34, 26, 2, 20, 84, 5, 35, 63, 97, 39, 86, 48, 96, 23, 94, 10, 71, 51, 28, 40, 55, 38, 92, 47, 13, 7, 95};\n    int N = sizeof(a) / sizeof(a[0]);\n\n    int duplicate = first(a, N);\n    printf(&#34;%d\\n&#34;, duplicate);\n\n    return 0;\n}</pre>","created":"2023-11-08T21:45:22Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[],"uid":"lne7to1q2jw37a","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>Άλλη μια ωραία λύση! Μοιάζει λίγο σε πνεύμα με την <a href=\"/class/llz2bkutusi4ap/post/168_f9\" target=\"_blank\" rel=\"noopener noreferrer\">https://piazza.com/class/llz2bkutusi4ap/post/168_f9</a></p>\n<p></p>\n<p>&gt; θεωρώ πως είναι αδύνατο να γνωρίζουμε ποιον αριθμό έχουμε ήδη προσπελάσει χωρίς να χρησιμοποιήσουμε έναν ακόμα πίνακα</p>\n<p></p>\n<p>Γίνεται δημιουργώντας 1-2 μεταβλητές ακόμα; Όχι πίνακα. Αύριο θα ανεβάσω hint.</p>","created":"2023-11-09T12:25:07Z","bucket_order":6,"bucket_name":"Last week","type":"feedback","tag_good":[{"role":"student","name":"Dimitris Andreakis","endorser":{},"admin":false,"photo":null,"id":"lne7to1q2jw37a","photo_url":null,"email":"sdi2300008@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["lne7to1q2jw37a"],"id":"lor5w61ohbm63o","updated":"2023-11-09T13:09:23Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"loqagsepaya104","updated":"2023-11-09T12:25:07Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Hint: μήπως μπορούμε να χρησιμοποιήσουμε κάποια ιδέα από αλγορίθμους εύρεσης κύκλων; Π.χ.:</p>\n<p></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Cycle_detection\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/Cycle_detection</a></p>","created":"2023-11-10T14:59:35Z","bucket_order":6,"bucket_name":"Last week","type":"followup","tag_good":[],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":[],"no_answer":0,"id":"losqunyjx3e5r6","updated":"2023-11-10T15:01:33Z","config":{"editor":"rte"}},{"anon":"no","folders":[],"data":null,"no_upvotes":0,"subject":"<p>Μπορούμε να αξιοποίησουμε τον αλγόριθμο του Floyd (<a href=\"https://en.wikipedia.org/wiki/Cycle_detection#Floyd&#39;s_tortoise_and_hare\" target=\"_blank\" rel=\"noopener noreferrer\">https://en.wikipedia.org/wiki/Cycle_detection#Floyd&#39;s_tortoise_and_hare</a>) ως εξής:</p>\n<p></p>\n<pre>\n#include &lt;stdio.h&gt;\n\nint findDuplicate(int arr[]){\n\n\tint tortoise = arr[0];\n\tint hare = arr[0];\n\n\t// Loop till we find the\n\t// duplicate element\n\twhile(1){\n\n\t\ttortoise = arr[tortoise];\n\t\thare = arr[arr[hare]];\n\n\t\tif (tortoise == hare) break;\n\t}\n\n\ttortoise = arr[0];\n\n\t// Loop to get start point\n\t// of the cycle as start\n\t// point will be the duplicate\n\t// element\n\n\t//printf(&#34;%d %d\\n&#34;, tortoise, hare);\n\twhile(tortoise != hare){\n\t\ttortoise = arr[tortoise];\n\t\thare = arr[hare];\n\t\t//printf(&#34;%d %d\\n&#34;, tortoise, hare);\n\t}\n\n\treturn tortoise;\n}\n\nint main(){\n\n\tint arr[101]={ \n\t56, 73, 8, 73, 56, 54, 90, 59, 31, 57, \n\t17, 66, 10, 76, 100, 80, 87, 19, 16, 30, \n\t49, 77, 50, 15, 64, 60, 67, 1, 42, 45, \n\t42, 88, 32, 61, 12, 11, 27, 81, 44, 14, \n\t36, 99, 22, 43, 65, 4, 46, 58, 98, 83, \n\t68, 24, 33, 29, 21, 79, 85, 69, 25, 75, \n\t82, 62, 52, 37, 74, 9, 93, 3, 91, 78, \n\t41, 18, 70, 72, 34, 26, 2, 20, 84, 5, \n\t35, 63, 97, 39, 86, 48, 96, 23, 94, 10, \n\t71, 51, 28, 40, 55, 38, 92, 47, 13, 7, \n\t95};\n\n\tint duplicate = findDuplicate(arr);\n\tprintf(&#34;%d\\n&#34;, duplicate);\n\n\treturn 0;\n}</pre>\n<p></p>\n<p>Ο αλγόριθμος βρίσκει έναν από όλους τους διπλούς αριθμούς. Δεν είναι απαραίτητα ο πρώτος διπλός αριθμός.</p>","created":"2023-11-10T20:17:35Z","bucket_order":4,"bucket_name":"Yesterday","type":"followup","tag_good":[],"uid":"lne7to1q2jw37a","children":[{"anon":"no","folders":[],"data":null,"subject":"<p>Ολόσωστα!! Γραμμική λύση με χρήση μόνο δύο νέων μεταβλητών. Αυτή είναι και η τελική λύση - δεν έχω άλλες προεκτάσεις να προτείνω σε αυτό το πρόβλημα - παρατηρήστε ότι ξεκίνησε με έναν απλό πίνακα που είχε απλά μερικούς ακεραίους. Δεν ξέρω αν σου ήταν προφανές γιατί αυτός ο αλγόριθμος λύνει το πρόβλημα - προσωπικά χρειάστηκα αρκετές επαναλήψεις την πρώτη φορά που τον είδα :)</p>\n<p></p>\n<p>Κλείνοντας, η ιδέα χρήσης δεικτών διαφορετικής ταχύτητας είναι αρκετά &#34;εξειδικευμένη&#34; αλλά ο αλγόριθμος του Floyd μπορεί να προκύψει συχνά ως σπαζοκεφαλιά (π.χ., σε συνεντεύξεις ή διαγώνισμα ή αλλού) και είναι καλό να την έχετε στο νου γιατί αν δεν το έχεις ξαναδεί είναι ψιλοαπίθανο να σου έρθει εκείνη την στιγμή.</p>","created":"2023-11-12T05:20:15Z","bucket_order":3,"bucket_name":"Today","type":"feedback","tag_good":[{"role":"student","name":"Dimitris Andreakis","endorser":{},"admin":false,"photo":null,"id":"lne7to1q2jw37a","photo_url":null,"email":"sdi2300008@di.uoa.gr","us":false,"facebook_id":null}],"uid":"llz2dt5jij45lu","children":[],"tag_good_arr":["lne7to1q2jw37a"],"id":"lov11cfj3n72t0","updated":"2023-11-12T16:37:44Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"id":"lot27lqeam56gw","d-bucket":"Yesterday","updated":"2023-11-12T05:20:15Z","config":{"editor":"rte"}}],"tag_good_arr":[],"no_answer":0,"anon_icons":true,"id":"loix4mhitmn276","config":{"editor":"rte","bypass_email":1,"has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":10,"num_favorites":1,"my_favorite":false,"is_bookmarked":true,"is_pinned":false,"is_tag_good":false,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756374232300,"default_anonymity":"no","my_post":true},"error":null,"aid":"mev7vb2ymrf2wd"}