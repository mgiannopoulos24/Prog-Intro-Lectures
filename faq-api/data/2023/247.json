{"result":{"history_size":2,"folders":["coding"],"nr":247,"data":{"embed_links":[]},"created":"2023-12-03T16:15:52Z","bucket_order":3,"no_answer_followup":0,"change_log":[{"anon":"no","uid":"lne7fdi537z2yt","data":"lppopch218s2vq","v":"all","type":"create","when":"2023-12-03T16:15:52Z"},{"anon":"no","uid":"lna15oi72z02ml","data":"lpprunkvcur2x9","to":"lppopcgynvg2vp","type":"s_answer","when":"2023-12-03T17:43:58Z"},{"anon":"no","uid":"lna15oi72z02ml","data":"lppt47qttub2d9","type":"s_answer_update","when":"2023-12-03T18:19:24Z"},{"anon":"no","uid":"lna15oi72z02ml","data":"lpptc9nhwen2ko","type":"s_answer_update","when":"2023-12-03T18:25:40Z"},{"anon":"no","uid":"llz2dt5jij45lu","data":"lpqqucacbjt4td","v":"all","type":"update","when":"2023-12-04T10:03:30Z"},{"anon":"no","uid":"llz2dt5jij45lu","data":"lpqre4o7qaf3yh","to":"lppopcgynvg2vp","type":"i_answer","when":"2023-12-04T10:18:53Z"},{"anon":"no","uid":"lna15oi72z02ml","data":"lpr7moxf6vr37x","type":"s_answer_update","when":"2023-12-04T17:53:27Z"}],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"Λειτουργία της fclose.","created":"2023-12-04T10:03:30Z","content":"Στην εκτέλεση της συνάρτησης fclose πρέπει να ελέγχουμε ότι έκλεισε με επιτυχία το αρχείο με την επιστροφή του 0, όπως αντίστοιχα πρέπει να κάνουμε και στην συνάρτησης fopen, ή είναι περιττό;"},{"anon":"no","uid":"lne7fdi537z2yt","subject":"Λειτουργία της fclose.","created":"2023-12-03T16:15:52Z","content":"     Στην εκτέλεση της συνάρτησης fclose πρέπει να ελέγχουμε ότι έκλεισε με επιτυχία το αρχείο με την επιστροφή του 0, όπως αντίστοιχα πρέπει να κάνουμε και στην συνάρτησης fopen, ή είναι περιττό;"}],"type":"question","anon_map":{},"tags":["coding","student"],"tag_good":[{"role":"student","name":"Ιάσων Μεγακλής","endorser":{"llz2bkutusi4ap":1701583872,"global":1701977118},"admin":false,"photo":null,"id":"lna15oi72z02ml","photo_url":null,"email":"sdi1800260@di.uoa.gr","us":false,"facebook_id":null},{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"EFSTATHIOS KONSTANTINOU","endorser":{},"admin":false,"photo":null,"id":"lndeeow72a32qc","photo_url":null,"email":"sdi2300099@di.uoa.gr","us":false,"facebook_id":null}],"unique_views":135,"children":[{"history_size":4,"folders":[],"data":{"embed_links":[]},"created":"2023-12-03T17:43:58Z","bucket_order":3,"tag_endorse":[{"role":"student","name":"Konstantinos","endorser":{},"admin":false,"photo":null,"id":"lne7fdi537z2yt","photo_url":null,"published":true,"email":"kostastsiotsias@gmail.com","us":false,"facebook_id":null},{"role":"professor","name":"Thanassis Avgerinos","endorser":{},"admin":true,"photo":null,"id":"llz2dt5jij45lu","photo_url":null,"email":"thanassis@di.uoa.gr","us":false,"admin_permission":15,"facebook_id":null},{"role":"student","name":"Dimosthenis Theodosiou","endorser":{},"admin":false,"photo":null,"id":"ln8vk6gs96f6z5","photo_url":null,"published":true,"email":"sdi2300051@di.uoa.gr","us":false,"facebook_id":null}],"bucket_name":"Today","history":[{"anon":"no","uid":"lna15oi72z02ml","subject":"","created":"2023-12-04T17:53:27Z","content":"<md>**Είχα και εγώ την ίδια απορία όταν διάβασα την ερώτηση σου οπότε μην πάρεις αυτά που γράφω και πάρα πολύ σοβαρά. Ορίστε τι κατάλαβα όταν το έψαξα.**\n\n---\nΔεν είναι περιττό, μάλιστα σε κάποιες περιπτώσεις (απ'ότι φαίνεται) είναι ζωτικής σημασίας.\n\n[Reference link από το stackoverflow](https://stackoverflow.com/questions/1954273/fclose-return-value-check)\n\nΟι Ορισμοί που δίνονται στο Παράρτημα Β της καθιερωμένης βιβλιοθήκης για τις συναρτήσεις που αναφέρονται είναι:\n```\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)\n```\nfwrite writes, from the array ptr, nobj objects of size size on stream. It returns the number of objects written, which is less than nobj on error.\n```\nint fflush(FILE *stream)\n```\nOn an output stream, fflush causes any buffered but unwritten data to be written; on an input stream, the effect is undefined. It returns EOF for a write error, and zero otherwise. fflush(NULL) flushes all output streams.\n```\nint fclose(FILE *stream)\n```\nfclose flushes any unwritten data for stream, discards any unread buffered input, frees any automatically allocated buffer, then closes the stream. It returns EOF if any errors occurred, and zero otherwise.\n\n*Μίλα ελληνικά (Κυριολεκτικά και μεταφορικά)*\n\nΌταν γίνεται εγγραφή σε ένα αρχείο στην πραγματικότητα γράφουμε σε μία περιοχή προσωρινής μνήμης (buffer) και όταν αυτή γεμίσει τότε γράφονται πραγματικά στο αρχείο. Η συνάρτηση `fflush()` αδειάζει το buffer και γράφει τυχόν δεδομένα που ήταν εκεί στο αρχείο. Με την σειρά της μια από τις δουλειές της `fclose()` είναι κάνει το ίδιο πράγμα πριν κλείσει το αρχείο, οπότε μπορεί να αποτύχει, άρα και έχει νόημα να διαβάσουμε τι επιστρέφει.\n\nΈστω το εξής πρόγραμμα:\n```\n#include <stdio.h>\n\nint main() {\n  FILE *fileToWrite;\n  char letters[5] = {\"Hello\"};\n  fileToWrite = fopen(\"justafile\", \"w\");\n  if (!fileToWrite) return 1;\n  fwrite(letters, sizeof(char), 5, fileToWrite);\n  fclose(fileToWrite);\n  return 0;\n}\n```\nΣτο πρόγραμμα εδώ ανοίγουμε το αρχείο justafile και γράφουμε το string `Hello` στην πραγματικότητα όμως μόνο αν βάλουμε το fclose θα εγγραφεί πραγματικά στο αρχείο. Αν βάλουμε `getchar();` πριν το `fclose()` (για να σταματήσουμε την εκτέλεση του προγράμματος) θα δούμε ότι το αρχείο παραμένει άδειο.\n\nΑντίστοιχα αν πριν από το `getchar();` βάλουμε`fflush(fileToWrite);` τότε πράγματι θα γράψουμε το String `Hello` στο αρχείο.\n```\n$ cat test\nHello\n```\nΑπό την άλλη αν γράφαμε αντί για 5 χαρακτήρες πολλά πράγματα στο αρχείο τότε η fwrite θα γέμιζε το buffer και θα γραφόντουσαν όντως στο αρχείο (Πάλι δεν είναι σίγουρο ότι δεν έχει μείνει κάτι στο buffer, άρα πάλι έχει νόημα). Δεν ξέρω αν είναι απόλυτα σωστό αυτό αλλά έτσι το καταλαβαίνω.\n\nΔεν είμαι σίγουρος αν έχει νόημα να ελέγξουμε το error code μετά από επιτυχή εκτέλεση fflush αλλά υποψιάζομαι πως έχει.\n\nΈνα παράδειγμα που δίνεται στο link είναι να ξεμείνεις από χώρο στον δίσκο όταν κάνεις `fclose()`.</md>"},{"anon":"no","uid":"lna15oi72z02ml","subject":"","created":"2023-12-03T18:25:40Z","content":"<md>**Είχα και εγώ την ίδια απορία όταν διάβασα την ερώτηση σου οπότε μην πάρεις αυτά που γράφω και πάρα πολύ σοβαρά. Ορίστε τι κατάλαβα όταν το έψαξα.**\n\nΑν κάποιος έχει σφαιρική εικόνα του τι ακριβώς συμβαίνει παρακαλώ να κάνει edit την απάντηση και να την βελτιώσει.\n\n---\nΔεν είναι περιττό, μάλιστα σε κάποιες περιπτώσεις (απ'ότι φαίνεται) είναι ζωτικής σημασίας.\n\n[Reference link από το stackoverflow](https://stackoverflow.com/questions/1954273/fclose-return-value-check)\n\nΟι Ορισμοί που δίνονται στο Παράρτημα Β της καθιερωμένης βιβλιοθήκης για τις συναρτήσεις που αναφέρονται είναι:\n```\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)\n```\nfwrite writes, from the array ptr, nobj objects of size size on stream. It returns the number of objects written, which is less than nobj on error.\n```\nint fflush(FILE *stream)\n```\nOn an output stream, fflush causes any buffered but unwritten data to be written; on an input stream, the effect is undefined. It returns EOF for a write error, and zero otherwise. fflush(NULL) flushes all output streams.\n```\nint fclose(FILE *stream)\n```\nfclose flushes any unwritten data for stream, discards any unread buffered input, frees any automatically allocated buffer, then closes the stream. It returns EOF if any errors occurred, and zero otherwise.\n\n*Μίλα ελληνικά (Κυριολεκτικά και μεταφορικά)*\n\nΌταν γίνεται εγγραφή σε ένα αρχείο στην πραγματικότητα γράφουμε σε μία περιοχή προσωρινής μνήμης (buffer) και όταν αυτή γεμίσει τότε γράφονται πραγματικά στο αρχείο. Η συνάρτηση `fflush()` αδειάζει το buffer και γράφει τυχόν δεδομένα που ήταν εκεί στο αρχείο. Με την σειρά της μια από τις δουλειές της `fclose()` είναι κάνει το ίδιο πράγμα πριν κλείσει το αρχείο, οπότε μπορεί να αποτύχει, άρα και έχει νόημα να διαβάσουμε τι επιστρέφει.\n\nΈστω το εξής πρόγραμμα:\n```\n#include <stdio.h>\n\nint main() {\n  FILE *fileToWrite;\n  char letters[5] = {\"Hello\"};\n  fileToWrite = fopen(\"justafile\", \"w\");\n  if (!fileToWrite) return 1;\n  fwrite(letters, sizeof(char), 5, fileToWrite);\n  fclose(fileToWrite);\n  return 0;\n}\n```\nΣτο πρόγραμμα εδώ ανοίγουμε το αρχείο justafile και γράφουμε το string `Hello` στην πραγματικότητα όμως μόνο αν βάλουμε το fclose θα εγγραφεί πραγματικά στο αρχείο. Αν βάλουμε `getchar();` πριν το `fclose()` (για να σταματήσουμε την εκτέλεση του προγράμματος) θα δούμε ότι το αρχείο παραμένει άδειο.\n\nΑντίστοιχα αν πριν από το `getchar();` βάλουμε`fflush(fileToWrite);` τότε πράγματι θα γράψουμε το String `hello` στο αρχείο.\n```\n$ cat test\nHello\n```\nΑπό την άλλη αν γράφαμε αντί για 5 χαρακτήρες πολλά πράγματα στο αρχείο τότε η fwrite θα γέμιζε το buffer και θα γραφόντουσαν όντως στο αρχείο (Πάλι δεν είναι σίγουρο ότι δεν έχει μείνει κάτι στο buffer, άρα πάλι έχει νόημα). Δεν ξέρω αν είναι απόλυτα σωστό αυτό αλλά έτσι το καταλαβαίνω.\n\nΔεν είμαι σίγουρος αν έχει νόημα να ελέγξουμε το error code μετά από επιτυχή εκτέλεση fflush αλλά υποψιάζομαι πως έχει.\n\nΈνα παράδειγμα που δίνεται στο link είναι να ξεμείνεις από χώρο στον δίσκο όταν κάνεις `fclose()`.\n\nΑντικειμενικά ούτε εγώ καταλαβαίνω καλά τα όσα εξήγησα οπότε θα ήθελα και εγώ μια αναλυτική εξήγηση για όλα αυτά παρακαλώ. :)</md>"},{"anon":"no","uid":"lna15oi72z02ml","subject":"","created":"2023-12-03T18:19:24Z","content":"<md>**Είχα και εγώ την ίδια απορία όταν διάβασα την ερώτηση σου οπότε μην πάρεις αυτά που γράφω και πάρα πολύ σοβαρά. Ορίστε τι κατάλαβα όταν το έψαξα.**\n\nΑν κάποιος έχει σφαιρική εικόνα του τι ακριβώς συμβαίνει παρακαλώ να κάνει edit την απάντηση και να την βελτιώσει.\n\n---\nΔεν είναι περιττό, μάλιστα σε κάποιες περιπτώσεις (απ'ότι φαίνεται) είναι ζωτικής σημασίας.\n\n[Reference link από το stackoverflow](https://stackoverflow.com/questions/1954273/fclose-return-value-check)\n\nΟι Ορισμοί που δίνονται στο Παράρτημα Β της καθιερωμένης βιβλιοθήκης για τις συναρτήσεις που αναφέρονται είναι:\n```\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)\n```\nfwrite writes, from the array ptr, nobj objects of size size on stream. It returns the number of objects written, which is less than nobj on error.\n```\nint fflush(FILE *stream)\n```\nOn an output stream, fflush causes any buffered but unwritten data to be written; on an input stream, the effect is undefined. It returns EOF for a write error, and zero otherwise. fflush(NULL) flushes all output streams.\n```\nint fclose(FILE *stream)\n```\nfclose flushes any unwritten data for stream, discards any unread buffered input, frees any automatically allocated buffer, then closes the stream. It returns EOF if any errors occurred, and zero otherwise.\n\n*Μίλα ελληνικά (Κυριολεκτικά και μεταφορικά)*\n\nΌταν γίνεται εγγραφή σε ένα αρχείο στην πραγματικότητα γράφουμε σε μία περιοχή προσωρινής μνήμης (buffer) και όταν αυτή γεμίσει τότε γράφονται πραγματικά στο αρχείο. Η συνάρτηση `fflush()` αδειάζει το buffer και γράφει τυχόν δεδομένα που ήταν εκεί στο αρχείο. Με την σειρά της μια από τις δουλειές της `fclose()` είναι κάνει το ίδιο πράγμα πριν κλείσει το αρχείο, οπότε μπορεί να αποτύχει, άρα και έχει νόημα να διαβάσουμε τι επιστρέφει.\n\nΈστω το εξής πρόγραμμα:\n```\n#include <stdio.h>\n\nint main() {\n  FILE *fileToWrite;\n  char letters[5] = {\"Hello\"};\n  fileToWrite = fopen(\"justafile\", \"w\");\n  if (!fileToWrite) return 1;\n  fwrite(letters, sizeof(char), 5, fileToWrite);\n  fclose(fileToWrite);\n  return 0;\n}\n```\nΣτο πρόγραμμα εδώ ανοίγουμε το αρχείο justafile και γράφουμε το string `Hello` στην πραγματικότητα όμως μόνο αν βάλουμε το fclose θα εγγραφεί πραγματικά στο αρχείο. Αν βάλουμε `getchar();` πριν το `fclose()` (για να σταματήσουμε την εκτέλεση του προγράμματος) θα δούμε ότι το αρχείο παραμένει άδειο.\n\nΑντίστοιχα αν πριν από το `getchar();` βάλουμε`fflush(fileToWrite);` τότε πράγματι θα γράψουμε το String `hello` στο αρχείο.\n```\n$ cat test\nHello\n```\nΔεν είμαι σίγουρος αν έχει νόημα να ελέγξουμε το error code μετά από επιτυχή εκτέλεση fflush αλλά υποψιάζομαι πως έχει.\n\nΈνα παράδειγμα που δίνεται στο link είναι να ξεμείνεις από χώρο στον δίσκο όταν κάνεις `fclose()`.\n\nΑντικειμενικά ούτε εγώ καταλαβαίνω καλά τα όσα εξήγησα οπότε θα ήθελα και εγώ μια αναλυτική εξήγηση για όλα αυτά παρακαλώ. :)</md>"},{"anon":"no","uid":"lna15oi72z02ml","subject":"","created":"2023-12-03T17:43:58Z","content":"<md>**Είχα και εγώ την ίδια απορία όταν διάβασα την ερώτηση σου οπότε μην πάρεις αυτά που γράφω και πάρα πολύ σοβαρά. Ορίστε τι κατάλαβα όταν το έψαξα.**\n\nΑν κάποιος έχει σφαιρική εικόνα του τι ακριβώς συμβαίνει παρακαλώ να κάνει edit την απάντηση και να την βελτιώσει.\n\n---\nΔεν είναι περιττό, μάλιστα σε κάποιες περιπτώσεις (απ'ότι φαίνεται) είναι ζωτικής σημασίας.\n\n[Reference link από το stackoverflow](https://stackoverflow.com/questions/1954273/fclose-return-value-check)\n\nΟι Ορισμοί που δίνονται στο Παράρτημα Β της καθιερωμένης βιβλιοθήκης για τις συναρτήσεις που αναφέρονται είναι:\n```\nsize_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)\n```\nfwrite writes, from the array ptr, nobj objects of size size on stream. It returns the number of objects written, which is less than nobj on error.\n```\nint fflush(FILE *stream)\n```\nOn an output stream, fflush causes any buffered but unwritten data to be written; on an input stream, the effect is undefined. It returns EOF for a write error, and zero otherwise. fflush(NULL) flushes all output streams.\n```\nint fclose(FILE *stream)\n```\nfclose flushes any unwritten data for stream, discards any unread buffered input, frees any automatically allocated buffer, then closes the stream. It returns EOF if any errors occurred, and zero otherwise.\n\n*Μίλα ελληνικά (Κυριολεκτικά και μεταφορικά)*\n\nΌταν γίνεται εγγραφή σε ένα αρχείο στην πραγματικότητα γράφουμε σε μία περιοχή προσωρινής μνήμης (buffer) και όταν αυτή γεμίσει τότε γράφονται πραγματικά στο αρχείο. Η συνάρτηση `fflush()` αδειάζει το buffer και γράφει τυχόν δεδομένα που ήταν εκεί στο αρχείο. Με την σειρά της μια από τις δουλειές της `fclose()` είναι κάνει το ίδιο πράγμα πριν κλείσει το αρχείο, οπότε μπορεί να αποτύχει, άρα και έχει νόημα να διαβάσουμε τι επιστρέφει.\n\nΈνα παράδειγμα που δίνεται στο link είναι να ξεμείνεις από χώρο στον δίσκο όταν κάνεις `fclose()`.\n\nΑντικειμενικά ούτε εγώ καταλαβαίνω καλά τα όσα εξήγησα οπότε θα ήθελα και εγώ μια αναλυτική εξήγηση για όλα αυτά παρακαλώ. :)</md>"}],"type":"s_answer","tag_endorse_arr":["lne7fdi537z2yt","llz2dt5jij45lu","ln8vk6gs96f6z5"],"children":[],"id":"lpprunkq9mk2x8","config":{"editor":"md"},"is_tag_endorse":true},{"history_size":1,"folders":[],"data":{"embed_links":[]},"created":"2023-12-04T10:18:53Z","bucket_order":3,"tag_endorse":[{"role":"student","name":"Konstantinos","endorser":{},"admin":false,"photo":null,"id":"lne7fdi537z2yt","photo_url":null,"published":true,"email":"kostastsiotsias@gmail.com","us":false,"facebook_id":null},{"role":"student","name":"Ιάσων Μεγακλής","endorser":{"llz2bkutusi4ap":1701583872,"global":1701977118},"admin":false,"photo":null,"id":"lna15oi72z02ml","photo_url":null,"email":"sdi1800260@di.uoa.gr","us":false,"facebook_id":null}],"bucket_name":"Today","history":[{"anon":"no","uid":"llz2dt5jij45lu","subject":"","created":"2023-12-04T10:18:53Z","content":"<p>Η απάντηση παραπάνω είναι εξαιρετική, δεν έχω να προσθέσω πολλά πέρα από:</p>\n<p></p>\n<p>1. Εφόσον ο υλοποιητής της συνάρτησης fclose (και αντίστοιχα της fflush) επέλεξε να γυρίσει διαφορετική τιμή (return value) όταν αποτύχει το κλείσιμο του αρχείου, αυτό σημαίνει ότι πιστεύει ότι αυτή η αποτυχία είναι πιθανώς σημαντική για τον προγραμματιστή που την καλεί. Επομένως η ερώτηση μετασχηματίζεται σε &#34;είναι σημαντικό το να μην κλείσουμε ένα αρχείο;&#34; για την συνέχεια του προγράμματός μας; Η απάντηση είναι πιθανώς ναι, καθώς αν η fclose αποτύχει, αυτό σημαίνει ότι ίσως να μην καταφέραμε να γράψουμε (για παράδειγμα) τα δεδομένα στο αρχείο μας και να το κλείσουμε επιτυχώς.</p>\n<p></p>\n<p>2. Όμως, τι μπορούμε να κάνουμε αν η fclose αποτύχει; Στα πλαίσια του μαθήματος αρκεί να τερματίσουμε το πρόγραμμα με ένα μήνυμα σφάλματος και exit(1) για την τέλεια απάντηση. Για το διαγώνισμα και τις ασκήσεις αν κάποιος ξεχάσει να τσεκάρει τι επιστρέφει η fclose δεν θα είναι μεγάλο πρόβλημα (όχι επειδή είναι οκ, απλά επειδή μόλις ξεκινάτε προγραμματισμό και θεωρείται πταίσμα σε σχέση με άλλα bugs). Σε επαγγελματικές εφαρμογές ίσως να χρειαστεί να κάνουμε κάτι παραπάνω ώστε να διαχειριστούμε το σφάλμα και να προσπαθήσουμε να κλείσουμε το αρχείο πιθανώς μετά από κάποια αναμονή ή διαδικασία καθαρισμού (πχ., του δίσκου).</p>"}],"type":"i_answer","tag_endorse_arr":["lne7fdi537z2yt","lna15oi72z02ml"],"children":[],"id":"lpqre4o5lbb3yg","config":{"editor":"rte"},"is_tag_endorse":false}],"tag_good_arr":["lna15oi72z02ml","lndeeow72a32qc","llz2dt5jij45lu"],"no_answer":0,"anon_icons":true,"id":"lppopcgynvg2vp","config":{"editor":"rte","has_emails_sent":1},"status":"active","drafts":{},"request_instructor":0,"request_instructor_me":false,"bookmarked":4,"num_favorites":0,"my_favorite":false,"is_bookmarked":true,"is_pinned":false,"is_tag_good":true,"q_edits":[],"i_edits":[],"s_edits":[],"t":1756374373535,"default_anonymity":"no"},"error":null,"aid":"mev7yc27dhd76h"}